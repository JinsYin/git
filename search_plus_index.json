{"./":{"url":"./","title":"简介","keywords":"","body":"Git 知识库 特点 最优的存储能力 非凡的性能 开源项目 容易做备份 支持离线操作 容易定制工作流程 参考 Git Handbook 如何高效的使用 Git git-tips LICENSE Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"quickstart.html":{"url":"quickstart.html","title":"快速入门","keywords":"","body":"入门 创建 Git 仓库 # 将已有项目纳入 Git 管理 $ cd myproject/ && git init # 新项目使用 Git 管理 $ git init newproject && cd newproject 创建完成后会在当前项目下自动生成 .git 目录及相关子文件。 把工作区文件提交到本地仓库（当前分支） HEAD 指向当前分支的最新版本 图片来源 暂存区就像是购物车，看到喜欢的商品可以先加入购物车（git add），在没付款前其实你是不确定购物车里的东西都想买，如果不想要了你可以直接删除购物车里的商品（git reset），确定好后再一次性下单（git commit）; 当然，你也可能看到某个喜欢的商品就直接下单了（git commit -a），而不是先加入购物车。 $ echo \"Git is a version control system.\" > README.md $ git add README.md $ git commit -m \"Create README.md\" # Git 添加文件到仓库需要 add，commit 两步，可以多次 add 不同的文件或目录，commit 可以一次提交很多文件 $ git add f1.md $ git add f2.md f3.md $ git add dir1 $ git add dir2 dir3 $ git commit -m \"Add three files and one dirctory.\" # 提交暂存区所有修改版本库 $ git commit [file1] [file2] ... -m [message] # 提交暂存区指定文件到版本库 关于 git add $ git add -A # 添加所有改动，包括所有新增、修改和删除；等价于 git add --all，可以只针对目录： git add --all /dir $ git add . # 添加所有新增和修改，但不包括删除 （会添加隐藏文件） $ git add * # 添加所有新增和修改，但不包括删除 （不会添加隐藏文件，不建议使用） $ git add -u # 添加所有修改和删除，但不包括新增 代码提交 # 也可以不 add，直接提交工作区自上次 commit 后的新的变化到版本仓库 $ git commit -a -m \"msg\" # 等价于 git add * && git commit -m \"msg\" （并不会添加隐藏文件） # 使用新的提交代替上一次提交，可以用来修改上一次的提交信息 $ git commit --amend -m [message] # 重做上一次提交，并包括指定文件的新变化 $ git commit --amend [file1] ... [fileN] -m [message] 撤销（unstage）暂存区的修改？ 撤销暂存区的修改之后，暂存区默认会回到最近一次 commit 的状态 $ git reset HEAD f1.md # 可以简写成 git reset f1.md $ git reset # 撤销所有暂存区的所有文件追踪 add 到暂存区后如何改名 $ git mv new.md old.md # 工作区也会跟着改名 add 到暂存区后如何删除？ 删除暂存区中文件相当于从购物车中删除添加的商品. 另外,如果一个文件已经被提交到了版本库, 突然又不想提交到远程仓库,可以先从暂存区删除再重新提交到版本库. # 同时删除工作区和暂存区中的 f1.md $ git rm (-f) f1.md # 等价于 git rm (-f) f1.md && git rm --cached f1.md # 仅删除暂存区中的 f1.md，而工作区中的 f1.md 会继续保留 # 如果删除前工作区中的 f1.md 还作了修改，则需要先丢弃工作区的修改 git checkout -- f1.md $ git rm --cached f1.md $ git rm -r --cached dir # 从暂存区删除某个目录 如果删错了可以再丢弃工作区的修改（git checkout -- f1.md）。 丢弃（discard）工作区的修改 工作区的文件发生修改后，要么添加（git add f1.md）到暂存区，要么丢弃（git checkout -- f1.md）工作区的修改。 情况1：f1.md 作了修改但还没有被添加到暂存区，撤销修改会回到和版本库最近一次 commit 的状态（前提是至少 commit 过一次）情况2：f1.md 作了第一次修改后被添加到暂存区，之后又作了第二次修改，撤销修改会回到暂存区时的状态。如果想回到版本库的状态，可以指定 commit id。 总之，撤销工作区的修改会回到最近近一次git commit或git add时的状态 $ git status $ git checkout -- f1.md # 撤销工作区某个文件的修改 $ git checkout . # 撤销工作区的所有修改 $ git checkout HEAD f1.md # 直接回到版本库状态（工作区和暂存区都会回到版本库状态） $ git status 查看工作区以及暂存区的状态 # 查看有哪些文件被添加、删除、修改（但不能查看具体修改了什么内容） $ git status 查看 difference 查看文本在工作区和暂存区的 difference $ git diff # 对比所有文件 （git diff --shortstat） $ git diff README.md # 对比某个文件 查看文本在暂存区和本地仓库的 difference 对比的是暂存区和本地仓库的最近一次 commit 的不同 $ git diff --cached # 对比所有文件（等价于 git diff --staged） $ git diff --cached README.md # 对比某个文件 查看文本在工作区和本地仓库的 difference $ git diff HEAD # 对比所有文件 $ git diff HEAD -- README.md # 对比某个文件 $ git diff test # 对比当前目录与 test 分支最新版本的不同，延伸： git diff master 等价于 git diff HEAD 查看文本在版本库和版本库的 difference $ git diff HEAD^ HEAD # 比较最近一次提交 commit 和上次提交 $ git diff SHA1 SHA2 # 比较两个历史版本之间的差异 对比分支的 difference $ git diff master dev # 对比 dev 分支和 master 分支最近一次 commit 时所有文件的不同 （dev 分支相对于 master 分支） $ git diff master dev > master-dev.diff # 将所有 difference 输出重定向 # 输出自 dev 和 master 分别开发以来，dev 分支上的 changed $ git diff master...dev 查看简单的 diff 结果，可以加上 --stat 参数 $ git diff --stat $ git diff --cached --stat ... $ git diff master...dev --stat 查看 commit 日志 # 第一列为 commit id $ git log $ git log --pretty=oneline # 一行显示 # 查看最新的3条 commit 日志 $ git log -3 # 建议使用 git lg 代替 git log $ git log dev # 查看 dev 分支的 commit 日志 $ git log master dev # 查看 master 分支和 dev 分支的 commit 日志 $ git log master ^dev # 查看 master 分支有，而 dev 分支没有的 commit 日志（对应：git log dev ^master） $ git log master..dev # 查看 dev 分支比 master 分支多提交了哪些内容（对应：git log master ^dev） $ git log master...dev # 不确定谁提交的多谁提交的少，单纯想看看有什么不一样（等同于 git log dev...master） $ git log --left-right master...dev # 查看每次提交都在哪个分支上（master 对应左箭头 ） 版本回退 HEAD 指向的是当前分支的最新版本，HEAD^ 指向的是当前分支的上一个版本，HEAD~10 指向的是当前分支的上 100 个版本。 # 也可以按 commit id 来回退版本 $ git reset --hard HEAD^ # 回退到上一个版本，工作区和暂存区会被重置到回退版本的状态 $ git reset --keep HEAD^ # 仅版本库回退，工作区和暂存区不变 $ git revert [commit] # 回退到指定版本，并新建一个 commit，但工作区和暂存区会被覆盖，可以先赞存本地修改（git stash） 查看 commit 日志和版本回退日志 如果版本回退之后又想回到未来，可以用该命令获取回退前的 commit id。 $ git reflog 缓存工作区和暂存区 主要会在两个地方用到 stash 功能： 合并分支之前，如果工作区和暂存区存在修改后并未提交的文件（不包括新增的），这时要么 commit 要么 stash； 当切换分支进行开发时，如果当前分支并未完成（即还没到 commit 的时候），可以先 stash 在切换分支开发。 $ git stash # 缓存 $ git stash # 列出所有缓存 $ git stash pop # 还原并删除 （== git stash apply stash@{0} && git stash drop stash@{0}） $ git stash clear # 清除所有 上传项目到 GitHub Git 支持 SSH 协议，本地 Git 仓库和 GitHub 仓库之间要建立加密连接需要将本地 SSH 公钥（id_rsa.pub）添加到远程 GitHub。 上传项目到 GitHub 需要3步： 第1步： 在 GitHub 中创建一个空的仓库（helloworld）。 第2步： 添加远程库origin，origin 是 Git 默认的叫法，也可以取别的名字。 $ git remote add origin git@github.com:jinsyin/helloworld.git 第3步： 把本地仓库的所有内容推送到远程库。实际上是把当前master分支推送到远程。 对于参数-u，Git 不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时可以简化命令。之后再提交不用再加-u（git push origin master） $ git push -u origin master # 推送 master 分支 $ git push -u origin dev # 推送 dev 分支 从 GitHub 克隆项目 从远程仓库克隆时，实际上 Git 自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin $ git remote $ git remote -v # 显示可以 fetch 和 push 的 origin 地址，如果没有 push 权限，就看不到 push 地址 Git 支持多种协议，包括 https，但使用 ssh 支持的原生 git 协议速度最快。 $ git clone https://github.com/jinsyin/helloworld.git $ git clone git@github.com/jinsyin/helloworld.git 克隆某个指定的分支 $ git clone -b registry-v2.6.1 https://github.com/docker/distribution-library-image.git 分支管理 HEAD严格来说不是指向提交，而是指向master（默认），master才是指向提交的，所以，HEAD指向的是当前分支。 创建 dev 分支，然后切换到 dev 分支 $ git checkout -b dev # 等价于 git branch dev && git checkout dev $ git branch # 查看分支 当创建新分支dev（git branch dev）时，Git 会新建一个指针dev，指向和master相同的提交。切换到dev分支（git checkout dev）后，HEAD会指向dev。 另外，多个分支是共用工作区和暂存区的，如果在master分支中工作区或暂存区有修改，切换到dev分支依然可以看到修改。 在dev分支上作修改并提交，dev指针会往前移动一步，而master指针不变。 把dev合并到master上，实际上是把master指向dev的当前提交。 合并完分支后，甚至可以删除dev分支。 git merge命令用于合并指定分支到当前分支。如果提示Fast-forward信息，表示这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 $ git merge dev 使用Fast-forward模式来合并分支的话，删除分支后，会丢掉分支信息。不过可以禁用Fast forward模式，这样在 merge 时就会生成一个新的 commit，并且分支历史上也可以看出分支信息。 $ git merge --no-ff -m \"merge with no-ff\" dev $ git branch -d dev # dev 分支被合并后可以直接删除，如果没有合并，使用这个命令删除会提示错误，但还是推荐优先使用这个命令删除分支 $ git branch -D dev # 如果 dev 分支没有被合并也可以使用这个命令来强删 解决冲突 当master分支和feature1分支各自都分别有新的提交（有冲突的提交），例如： # master: Creating a new branch is quick & simple. # feature1: Creating a new branch is quick AND simple. 因为两个分支的提交存在冲突，所以合并会出错，修改冲突文件后在add、commit后即可解决冲突。 $ git merge feature1 $ git status # 查看分支的合并情况 $ git log --graph --pretty=oneline --abbrev-commit # 合并分支之后也可以撤销 $ git merge -abort 分支策略 .gitigonre 忽略特殊文件 .gitignore 模板 github/gitignore .gitignore 自动生成网站 gitignore.io $ git check-ignore -v App.class # 检查忽视规则 配置别名 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch # 命令 git reset HEAD file 可以把暂存区的修改撤销掉（unstage），重新放回工作区 $ git config --global alias.unstage 'reset HEAD' $ git unstage test.py # 跟踪 commit、合并日志 $ git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" $ git lg -5 # 查看本地仓库配置 $ cat .git/config # 查看当前用户配置（--global），注： system 是整台电脑，global 是当前用户 $ cat ~/.gitconfig 搭建 Git 服务器 Docker Gitlab image 参考文章 廖雪峰的 Git 教程 阮一峰的常用 Git 命令清单 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/":{"url":"basics/","title":"基础","keywords":"","body":"Git 基础 版本控制 安装 Git Workspace：工作区 Index / Stage：暂存区 Repository：本地仓库/本地数据库 Remote：远程仓库 三种状态 & 三个工作区域 已提交（committed） - 表示数据已安全保存到本地数据库中 已修改（modified） - 表示修改了文件，但还未保存到本地数据库 已暂存（staged） - 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此引入 Git 项目的三个工作区域的概念：工作目录（working tree）、暂存区（staging area） 以及 Git 仓库（Git directory）。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。从其他计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/getting-started.html":{"url":"basics/getting-started.html","title":"入门","keywords":"","body":"Git 入门 版本控制 版本控制系统（VCS）记录项目文件的变化情况（包括文件的内容、权限），以便将来可以将某个文件甚至整个项目回退到之前的状态（概括为 “回溯”），亦或者追踪不同修订版本的文件差异（概括为 “追踪”）。 演变历史 代表 描述 无 ~ 复制项目目录以保存不同的版本。简单方便，但难以管理 本地式 RCS 采用简单的本地数据库来记录文件的历次更新差异 集中式 CVS、SVN 单一的中央服务器保存所有文件的修订版本，协同工作者使用客户端连接服务器，以提交更新或者拉取最新文件。 1. 集中式版本管理服务器，存在单点故障问题 2. 具备文件版本管理和分支管理功能 3. 集成效率高 4. 客户端必须时刻和服务器相连 分布式 Git 服务端和客户端均保存完整的版本历史，各端均可以独立进行版本管理 安装 Git Linux： # Ubuntu $ sudo apt-get install -y git # CentOS $ sudo yum install -y git 验证检查： $ git --version git version 2.20.1 参考 A short history in Version Control Systems – RCS, ClearCase, SVN, Git Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/branch/":{"url":"basics/branch/","title":"分支管理","keywords":"","body":"Git 分支的管理 HEAD 指针和分支引用 分支 - 指向的是 commit HEAD - 指向的也是 commit；默认情况指向的是 分支指向的 commit，如果指向的是非分支指向的 commit，这是就处于 分离头指针（Detached HEAD） 状态 命令详解 git-checkout - 切换分支或恢复工作区文件 git-branch 分支合并 快进（fast-forward）合并：只更新分支指针。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/experiment.html":{"url":"basics/experiment.html","title":"实验","keywords":"","body":"实验 创建 Git 仓库 $ git init git_learning && cd git_learning 最小配置 $ git config --global user.name \"jinsyin\" $ git config --global user.email \"jinsyin@gmail.com\" 小试牛刀 创建文件 $ echo \"Git 学习笔记\" > README.md 查看文件状态 # 此时 README.md 文件还没有被 Git 管理和追踪 $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) 将文件添加到暂存区 $ git add README.md 再次查看文件状态 # 此时 README.md 文件已被 Git 管理和追踪，下一步可以选择提交（commit）到本地仓库或者从暂存区撤销（unstage）到工作区 $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached ...\" to unstage) new file: README.md 提交到本地仓库 $ git commit -m \"Add README\" [master (root-commit) 7810d92] Add README 1 file changed, 1 insertion(+) create mode 100644 README.md 查看提交日志 $ git log commit 7810d9296e19d518bdcdab8af495d03f3673e728 (HEAD -> master) Author: jinsyin Date: Tue Feb 19 16:00:25 2019 +0800 Add README Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/file-status.html":{"url":"basics/file-status.html","title":"文件状态","keywords":"","body":"Git 的文件状态 文件状态 描述 tracked 之前已经被暂存或被提交的文件 unstracked 还没有被暂存或被提交的文件 ignored .gitignore 文件中被忽略的文件 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/server/":{"url":"basics/server/","title":"服务端","keywords":"","body":"Git 服务器篇 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/server/gitweb.html":{"url":"basics/server/gitweb.html","title":"GitWeb","keywords":"","body":"GitWeb 参考 服务器上的 Git - GitWeb Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/server/protocol.html":{"url":"basics/server/protocol.html","title":"Git 协议","keywords":"","body":"Git 协议 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/server/setup.html":{"url":"basics/server/setup.html","title":"搭建 Git","keywords":"","body":"搭建 Git 参考 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/workflow.html":{"url":"basics/workflow.html","title":"工作流程","keywords":"","body":"工作流程 基本工作流程 在工作目录中修改文件 暂存文件，即将文件的快照放入暂存区 提交更新，即找到暂存区的文件，将快照永久性存储到 Git 仓库目录 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/workflow/":{"url":"basics/workflow/","title":"workflow","keywords":"","body":"Git 工作流 Git flow Github flow Gitlab flow 参考 Git 使用规范流程 Git 分支开发工作流 分布式 Git - 分布式工作流程 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"principle/lifecycle.html":{"url":"principle/lifecycle.html","title":"文件生命周期","keywords":"","body":"Git 文件的生命周期 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"principle/protocol.html":{"url":"principle/protocol.html","title":"传输协议","keywords":"","body":"传输协议 本地协议 HTTP/HTTPS SSH 示例 $ git clone /Users/in/Documents/sambashare/gitbook/notes notes.git $ git clone file:///Users/in/Documents/sambashare/gitbook/notes $ git clone https://github.com/JinsYin/notes.git $ git clone git@github.com:JinsYin/notes.git Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"principle/object.html":{"url":"principle/object.html","title":"Git 对象","keywords":"","body":"Git 对象 Git 是一个「内容寻址文件系统（content-addressed filesystem）」，其核心部分是一个简单的健值对数据库（key-value data store）。当向数据库插入任意类型的内容时，它会返回一个健值，通过该健值可以在任意时刻再次检索（retrieve）该内容。另外，所有 Git 对象都存储在当前仓库的 .git/objects 目录中。 对象 描述 commit tree 目录 blob 常规文件（regular file）、软连接 一个 commit 对象有且只包含一个 tree 对象 一个目录对应一个 tree 对象，而 commit 则相当于根目录 commit 对象 格式 tree [CommitID] // ① author [用户名] [邮箱] [时间戳] [时差] committer [用户名] [邮箱] [时间戳] [时差] [提交的信息] ① 的对象类型总是 tree，Git 使用一个总的 tree 存储提交的第一级内容（目录或文件），换句话说，每个 commit 下必然包含一个 tree 示例 tree b17a09b164f5f1ffc8b31ca5980934ffa39faca3 author jinsyin 1550736153 +0800 committer jinsyin 1550736153 +0800 Add README tree 对象 格式 [文件类型+文件权限] [对象类型] [对象 ID] [对象名称] 文件类型：100（regluar file）、101（symbolic link）、111（gitlink） 文件权限：（略） 示例 040000 tree 78d61e987a3dadc0f28434bf7241c5f5f90cc2c0 doc 100644 blob c25857953927ed759aa024b43432a278e1fb163d readme blob 对象 blob 对象的内容其实就是文件自身的内容。需要注意的是，查看二进制文件（图片、视频、Word、PPT 等）的内容会显示乱码。 常用命令 # 查看对象类型 $ git cat-file -t [ObjectID] # 查看对象内容 $ git cat-file -p [ObjectID] 实验一 · 理解 Git 对象 新建 Git 版本库 $ git init gitobj && cd gitobj/ # 添加项目内容 $ mkdir doc && echo 'Hello,world' > doc/readme # 空（此时并无对象文件） $ find .git/objects -type f 添加到暂存区 $ git add . # Git 创建了一个对象文件 $ find .git/objects -type f .git/objects/c2/5857953927ed759aa024b43432a278e1fb163d # 查看对象文件的类型 $ git cat-file -t c25857 # blob # 查看对象文件的内容 $ git cat-file -p c25857 # Hello,world 提交到版本库 $ git commit -m 'Document' # Git 创建了 4 个对象文件 $ find .git/objects -type f .git/objects/d8/6e7d889a04bcead0654efeaea4dd819dd5ef96 .git/objects/78/d61e987a3dadc0f28434bf7241c5f5f90cc2c0 .git/objects/c2/5857953927ed759aa024b43432a278e1fb163d .git/objects/96/42a9eb10b8fce3ec11e3d17ccba83825a256f6 # 对象类型 $ git cat-file -t d86e7d # commit $ git cat-file -t 9642a9 # tree $ git cat-file -t 78d61e # tree $ git cat-file -t c25857 # blob # 提交日志（可以获取入口的对象 ID） $ git log --oneline -1 d86e7d (HEAD) Document # 对象内容 $ git cat-file -p d86e7d tree 9642a9eb10b8fce3ec11e3d17ccba83825a256f6 author jinsyin 1550733848 +0800 committer jinsyin 1550733848 +0800 Document $ git cat-file -p 9642a9 040000 tree 78d61e987a3dadc0f28434bf7241c5f5f90cc2c0 doc $ git cat-file -p 78d61e 100644 blob c25857953927ed759aa024b43432a278e1fb163d readme $ git cat-file -p c25857 Hello,world 整个数据结构类似于关系型数据库中主键和外键之间的关系。 实验二 · 玩转 Git 对象 通过底层命令 hash-object 可以将任意数据保存到 .git 目录，并返回相应的健值。 $ echo 'test content' | git hash-object -w --stdin d670460b4b4aece5915caf5c68d12f560a9fe3e4 $ find .git/objects -type f .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 $ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 test content 实验三 · 内容寻址 相同内容的 blob 文件，其 blob 的 hash 值也相同。 新建 Git 仓库 $ git init G3 && cd G3/ # 添加相同的项目内容的三个不同文件 $ echo \"Hello\" | tee README.md README.rst README.txt 提交到版本库 $ git add . # Git 只创建了一个对象 $ find .git/objects/ -type f .git/objects/c2/5857953927ed759aa024b43432a278e1fb163d $ git cat-file -t c25857 # blob $ git cat-file -p c25857 # Hello,world 添加多个内容相同的文件到版本库，Git 仅存储一份。 参考 Git 内部原理 - Git 对象 Git 由浅入深之存储原理 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"principle/refs.html":{"url":"principle/refs.html","title":"Git 引用","keywords":"","body":"Git 引用 引用 路径 本地分支 .git/refs/heads/ 远程追踪分支 .git/refs/remotes// stash .git/refs/stash tag .git/refs/tags/ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"dotfiles/dotgit.html":{"url":"dotfiles/dotgit.html","title":".git","keywords":"","body":".git 目录结构 Git 的数据结构存储在当前项目的 .git 目录中。 ├── COMMIT_EDITMSG ├── FETCH_HEAD ├── HEAD ├── MERGE_MSG.save ├── ORIG_HEAD ├── branches ├── config ├── description ├── gitk.cache ├── gitweb │ ├── access.log │ ├── error.log │ ├── gitweb_config.perl │ ├── tmp │ ├── webrick │ │ └── wrapper.sh │ └── webrick.rb ├── hooks │ ├── applypatch-msg.sample │ ├── commit-msg.sample │ ├── post-update.sample │ ├── pre-applypatch.sample │ ├── pre-commit.sample │ ├── pre-push.sample │ ├── pre-rebase.sample │ ├── prepare-commit-msg.sample │ └── update.sample ├── index ├── info │ ├── exclude │ └── refs ├── logs │ ├── HEAD │ └── refs │ ├── heads │ │ ├── master │ │ ├── master-backup │ │ └── tes │ ├── remotes │ │ ├── origin │ │ │ ├── HEAD │ │ │ └── master │ │ └── wrf │ └── stash ├── objects │ ├── xx │ │ ├── zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz # 完整的对象 ID 是 xxzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz │ │ └── ...................................... │ ├── .. │ │ ├── ...................................... │ │ └── ...................................... │ ├── info │ │ └── packs │ └── pack │ ├── pack-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.idx │ ├── pack-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.pack │ ├── ................................................. │ └── .................................................. ├── packed-refs └── refs ├── heads # 本地分支 │ ├── master │ ├── master-backup │ └── tes ├── remotes # 远程追踪分支 │ ├── origin │ │ ├── HEAD │ │ └── master │ └── wrf ├── stash └── tags .git/HEAD $ cat .git/HEAD ref: refs/heads/master $ git checkout -b test $ cat .git/HEAD ref: refs/heads/test .git/config $ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true $ git config --local user.name 'Jins Yin' $ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [user] name = Jins Yin .git/refs/ $ cat .git/refs/heads/master b174f8a55227aa3c882ac4a77936005d45c9dd39 # 查看对象类型 $ git cat-file -t b174f8 commit $ ls -l .git/objects/b1/74f8a55227aa3c882ac4a77936005d45c9dd39 -r--r--r-- 1 in staff 203 Sep 11 16:07 .git/objects/b1/74f8a55227aa3c882ac4a77936005d45c9dd39 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"dotfiles/dotgitattributes.html":{"url":"dotfiles/dotgitattributes.html","title":".gitattributes","keywords":"","body":".gitattributes ~/.gitconfig: # 将二进制 PDF 转换为可读文本的过滤器 [diff \"pdfconv\"] textconv=pdftohtml -stdout # brew install pdftohtml 仓库根目录下创建 .gitattributes *.pdf diff=pdfconv // 将相应的文件模式与 pdfconv 过滤器进行关联 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"dotfiles/dotgitconfig.html":{"url":"dotfiles/dotgitconfig.html","title":".gitconfig","keywords":"","body":".gitconfig # Git 别名不区分大小写 $ cat ~/.gitconfig [alias] aa = add -A . amend = commit --amend # 修订最近一次提交的 message，并提交暂存区的内容 alias = !\"fn() { git aliases | awk -v pattern=$1 '$1==pattern'; }; fn\" # or: git config --global alias.$1 aliases = !git config --get-regexp \"^alias\\\\.\" | cut -c 7- | sed 's| | = |' b = branch -a -v br = branch brd = branch -d brdd = branch -D brdr = branch -d -r cat = cat-file -p cat-head = !git cat-file -p $(git hh) cat-type = cat-file -t cat-size = cat-file -s cat-exit = cat-file -e ce = config -e --global cel = config -e --local cg = config --global # 显示 commit 相对于 parent 的更新（`git show COMMIT` 相似但不支持 merge commit） # git ch | git ch 9b965a1 | git ch 9b965a1 README.md | git ch HEAD README.md ch = !\"fn() { git diff --patch --stat $(git parent \\\"${1:-HEAD}\\\") \\\"${1:-HEAD}\\\" -- $2; }; fn\" child = \"!bash -c 'git log --format=%H --reverse --ancestry-path ${1:-HEAD}..${2:\\\"$(git rev-parse --abbrev-ref HEAD)\\\"} | head -1' -\" parent = !\"fn() { git rev-parse \\\"${1:-HEAD}~1\\\" | head -1; }; fn\" ci = commit cl = clone clb = clone --single-branch --branch # git clb clhead = clone --depth=1 # git clhead co = checkout cob = checkout -b count = shortlog -sn date = !\"fn() { date +'%Y:%m:%d %H:%M:%S'; }; fn\" d = diff --patch --stat dc = diff --cached --patch --stat dt = difftool dtc = difftool --cached dis = restore # 丢弃（discard）工作区的修改；git dis = git discard discard = checkout -- # 丢弃（discard）工作区的修改; git dis = git discard e = !vim edit = !vim f = fetch find = !git ls-files | grep -i # 查找工作区和暂存区的文件 gr = grep -Ii --line-number head = rev-parse --abbrev-ref HEAD hh = log --pretty=format:'%Cred%h%Creset' -n 1 # head hash hash = !\"fn() { git rev-parse \\\"${1:-HEAD}\\\"; }; fn\" // 获取 Git 对象、分支的完整哈希；git hash HEAD~1 | git hash master | git hash a858be （返回完整的 commit/tree/blob hash） id = !\"fn() { git log --pretty=format:'%Cred%h%Creset' -n 1 \\\"${1:-HEAD}\\\" | xargs echo; }; fn\" # short hash k = !gitk --all --branches ke = !gitk --all $(git log -g --pretty=%h) ignore = !vim $(git cwd)/.gitignore last = lg -n1 HEAD lg = log --abbrev-commit --color --date=format:'%Y-%m-%d' --decorate --graph --pretty=format:'%C(green)%ad%Creset %Cred%h%Creset -%C(yellow)%d%Creset %s %C(blue)[%cn]%Creset' la = lg --all lstat = lg --stat ls = ls-files # ls -c, ls -m, ls -d ... lsfile = ls-files lstree = ls-tree lf = ls-file lt = ls-tree ltr = ls-tree -r mg = merge mod = submodule modprobe = !git submodule add git://github.com/$1 $2/$(basename $1) modupdate = submodule update --init --recursive modpull = !git submodule foreach git pull --tags origin master pk = cherry-pick pka = cherry-pick --abort pkc = cherry-pick --continue rd = rm -r rb = rebase git rbc // 不变 rbc = rebase --continue rbabort = rebase --abort # 防止敲错（a 和 s 靠的太近） rbskip = rebase --skip # 防止敲错（a 和 s 靠的太近） rbquit = rebase --quit rbedit = rebase --edit-todo rbpatch = am --show-current-patch # 查看 GitRebase 因冲突而停止时所应用的 commit/patch rbours = checkout --ours # rebase 合并遇到冲突而停止时，应用最近一次提交成功的内容来解决冲突 rbtheirs = checkout --theirs # rebase 合并遇到冲突而停止时，应用补丁（当前正在应用的 commit）的内容来解决冲突 rbchanged = diff HEAD -- rbfixed = diff --cached HEAD -- rl = reflog --abbrev-commit --color --date=format:'%Y-%m-%d' --pretty=format:'%C(green)%ad%Creset %Cred%h%Creset -%C(yellow)%d%Creset %C(cyan)%gd%Creset %C(auto)%gs%C(reset) %C(blue)[%cn]%Creset' root = rev-parse --show-toplevel # Git root directory rr = remote # Remote Repositories rrv = rr -v rmc = rm --cached s = status st = status ss = status --short sh = stash sl = stash list --date=format:'%Y-%m-%d' --pretty=format:'%Cgreen%ad %C(red)%h%C(reset) - %C(yellow)(%gD)%C(reset): %s %C(blue)[%cn]%C(reset)' shapply = stash apply shdrop = stash drop shpop = stash pop shpatch = stash show -p # git shpatch \"stash@{0}\" / git shpatch \"stash@{1}\"；储藏前和储藏后的差异（储藏后发生了修改不会影响补丁的内容） shsave = stash save -u shunapply = !git stash show -p | git apply -R snap = !git stash save \"snapshot: $(date +'%Y:%m:%d-%H:%M:%S')\" && git stash apply 'stash@{0}' tar = !\"fn() { top=$(git topname); date=$(date +'%Y%m%d'); name=$top-$date.tar; cd $top; tar cvf $name $top; echo '\\n'; ls -l $name; }; fn\" targz = !\"fn() { top=$(git topname); date=$(date +'%Y%m%d'); name=$top-$date.tar.gz; cd $top; tar cvzf $name $top; echo '\\n'; ls -l $name; }; fn\" tree = ls-tree tr = ls-tree -r # 递归查找 tree 对象；git tr HEAD~1 os/linux | git tr HEAD~1 | grep os/linux tree-head = !git ls-tree -r $(git hh) unadd = reset HEAD -- # git unstage = git unadd unstage = restore --staged # 将暂存区的所有 重置为 HEAD 时的状态 uncommit = reset --soft HEAD~1 # 撤销最近一次提交（不重置工作区和暂存区） undo = reset --mixed HEAD~1 # 撤销最近一次提交并重置暂存区，但不重置工作区，即 git undo = git uncommit + git unstage upname = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD) # upstream name who = log -i -n1 --pretty=format:'Author:%C(blue)[%an]%Creset Email:%C(yellow)%Creset' [color] ui = auto [color \"branch\"] current = green reverse local = yellow remote = red # [color \"diff\"] # meta = yellow bold # frag = magenta bold # old = red bold # new = green bold [color \"status\"] added = green changed = yellow unmerged = magenta # 未合并的冲突文件 untracked = red [diff] tool = vimdiff [difftool] prompt = false [http] proxy = http://127.0.0.1:1080 # HTTP 代理 [pager] diff = gsed \\\"s|diff --git|\\\\n~~~\\\\n\\\\ndiff --git|\\\" | less # brew install gnu-sed show = gsed \\\"s|diff --git|\\\\n~~~\\\\n\\\\ndiff --git|\\\" | less # brew install gnu-sed branch = cat # zsh Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"dotfiles/dotgitignore.html":{"url":"dotfiles/dotgitignore.html","title":".gitignore","keywords":"","body":".gitignore 参考 github.com/github/gitignore Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-help.html":{"url":"cli/git-help.html","title":"git help","keywords":"","body":"git help 显示 Git 及其命令行的帮助信息（手册页）。 用法 git help [-a|--all [--[no-]verbose]] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE] 其他 $ git help # git help branch $ git --help # git branch --help $ git -h # git branch -h $ man git- # man git-branch Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-add.html":{"url":"cli/git-add.html","title":"git add","keywords":"","body":"git add 添加文件内容到暂存区。 GitAdd 相当于对工作目录的当前状态做一份快照，而 GitReset 则用于撤销一个提交或暂存的快照，即 git add 和 git reset 是两个相反的操作，而 git commit 则提交暂存区的快照到版本库。 选项 参数选项 描述 git add . git add -u 将已追踪（tracked）文件（即已被 Git 管理）的更新（update：修改 和 删除）添加到暂存区 git add -A 将所有文件（已被追踪 tracked 和未被追踪 untracked）的变更（changes：修改、删除 和 新建）添加到暂存区 tracked - 已被追踪，即已经通过 git add 操作将文件交由 Git 管理 untracked - 未被追踪，即还没有通过 git add 将文件交由 Git 管理 staged - 已被暂存，即已经加入到暂存区 用例 git add git add 撤销暂存区 如果该文件是一个新建文件（即未 commit），使用 git rm --cached xxx 命令可以将文件从暂存区撤销 如果该文件是一个修改文件（即已 commit），使用 git reset HEAD xxx 命令可以将文件从暂存区撤销 文件重命名 方式一 $ mv README README.md $ git add README README.md # or: git add . 方式二 $ mv README README.md $ git add README.md $ git rm README 方式三 $ git mv README README.md Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-apply.html":{"url":"cli/git-apply.html","title":"git apply","keywords":"","body":"git apply 对文件和/或暂存区应用一个补丁。 用法 git apply [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way] [--apply] [--no-add] [--build-fake-ancestor=] [-R | --reverse] [--allow-binary-replacement | --binary] [--reject] [-z] [-p] [-C] [--inaccurate-eof] [--recount] [--cached] [--ignore-space-change | --ignore-whitespace] [--whitespace=(nowarn|warn|fix|error|error-all)] [--exclude=] [--include=] [--directory=] [--verbose] [--unsafe-paths] [...] 选项 选项 描述 -R、--reverse 反向应用补丁 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-archive.html":{"url":"cli/git-archive.html","title":"git archive","keywords":"","body":"git archive 选项 选项 描述 -l、--list 列出支持的归档格式 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-bisect.html":{"url":"cli/git-bisect.html","title":"git bisect","keywords":"","body":"git bisect Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-blame.html":{"url":"cli/git-blame.html","title":"git blame","keywords":"","body":"git blame Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-branch.html":{"url":"cli/git-branch.html","title":"git branch","keywords":"","body":"git branch HEAD 指针和分支引用 分支 - 指向的是 commit HEAD - 指向的也是 commit；默认情况指向的是 分支指向的 commit，如果指向的是非分支指向的 commit，这是就处于 分离头指针（Detached HEAD） 状态 分支管理策略 master分支是主分支，应该是非常稳定的，仅用来发布新版本（平时不能在上面干活），因此要时刻与远程同步； dev分支是开发分支，是不稳定的，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发； 每个人都在dev分支上干活，每个人都应该有自己的分支，时不时地往dev分支上合并就可以了。 选项 参数 说明 - 切换回上一个分支，类似 cd - 命令 -d, --delete 安全删除分支；要求该分支被完全合并到上游分支 -D 强制删除分支；等同 --delete --force -r 列出本地远程追踪（remote-tracking）分支 -r -d 删除本地远程追踪（remote-tracking）分支 -a, --all 列出所有本地分支和远程追踪（remote-tracking）分支 用例 用例 描述 git branch -d -r origin/ 删除本地 GitFetch 下来的远程分支（不会删除远程仓库的此分支）；等同于 rm .git/refs/remotes/origin/ 创建分支： $ git branch $ git branch --track [name] [remote-branch] # 新建分支，并与指定远程分支建立追踪关系 切换分支： $ git checkout $ git checkout - # 求换到上一个分支（类似 cd -） 创建 + 切换分支： $ git checkout -b $ git checkout -b [origin/name] # 同时还要与远程分支进行关联 建立分支追踪关系： $ git branch --set-upstream-to=origin/ dev # 将本地分支与指定的远程分支建立追踪关系 合并某分支到当前分支： $ git merge # Fast-Forward 模式，删除分支后不会保留 commit 日志 $ git merge --no-ff # Non-Fast-Forward 模式，删除分支后会保留 commit 日志（推荐） $ git cherry-pick [commit] # 选择一个 commit，合并进当前分支 删除分支： $ git branch -d # 删除本地分支，被合并后才能被删除，或者是空分支也能被删除 $ git branch -D # 删除本地分支，没被合并也能被删除 # 前两个命令都可以用于删除远程分支（需要确保远程分支不是 Default branch） $ git push origin :[branch] $ git push origin --delete [branch] $ git branch -dr [origin/branch] # 只在本地删除，远程并没有真正删除 推送分支到远程： $ git push -u origin master # 第一次推送需要建立分支关联 $ git push origin master # 第二次推送不用再加 -u 对比分支差异： $ git log dev ^master # 查看 dev 分支有的，而 master 分支没有的内容 $ git log master ^dev # 查看 master 分支有的，而 dev 分支没有的内容 示例 直接对远程分支进行修改 git fetch origin master ... git checkout -b omaster origin/master ... # 修改并提交，如 git rebase -i ... ... git push -f origin omaster:master # 只能强制（如果省略 omaster，则是将本地的 master 推送到远程的 master） See learngitbranching.js.org Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-cat-file.html":{"url":"cli/git-cat-file.html","title":"git cat-file","keywords":"","body":"git cat-file 提供仓库对象的内容、类型和大小信息 用法 git cat-file (-t [--allow-unknown-type]| -s [--allow-unknown-type]| -e | -p | | --textconv | --filters ) [--path=] git cat-file (--batch | --batch-check) [ --textconv | --filters ] [--follow-symlinks] 选项 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-checkout.html":{"url":"cli/git-checkout.html","title":"git checkout","keywords":"","body":"git checkout 切换分支或还原工作区文件 用法 git checkout [-q] [-f] [-m] [] git checkout [-q] [-f] [-m] --detach [] git checkout [-q] [-f] [-m] [--detach] git checkout [-q] [-f] [-m] [[-b|-B|--orphan] ] [] git checkout [-f|--ours|--theirs|-m|--conflict=] [] [--] ... git checkout [] [--] ... git checkout (-p|--patch) [] [--] [...] # 还原工作区文件 选项 参数 说明 -- [filename] 用暂存区文件覆盖工作区文件 . 相当于 git add . 的反动作，取消暂存区的所有 add 内容 用例 git checkout -b omaster origin/master // 基于远程追踪分支 origin/master 建立新分支 omaster，并切换到新分支 git checkout -b feature 0cece20 // 基于 0cece20 提交建立新分支 feature，并切换到新分支 分离头指针（Detached HEAD） 分离头指针，即 HEAD 指针没有指向分支引用，而是指向（checkout）了某个具体的 commit 。 哪些操作会导致分离头指针 # 1 $ git checkout [commit_id] # 2 $ git rebase 切换到 master 前的解决办法： # 强制将 master 分支执行头指针的位置（如果 master 分支还有新提交的话慎用） $ git branch -f master HEAD && git checkout master # 使用新分支来保存分离的提交 $ git branch v001 [commit-id] 切换到 master 后的解决办法： # 查看最近的提交 ID，然后再 checkout 回来；不过如果不管它，过段时间会作为垃圾回收掉 $ git reflog 实验一 · 分离头指针 git init e1 && cd e1/ echo 'print(\"Hello,world\")' > main.py echo '# Python Document' > README.md git add main.py && git commit -m 'Python Code' git add README.md && git commit -m 'Python Document' # 提交历史 $ git log --oneline c155d2e (HEAD -> master) Python Document 9e89670 Python Code # 分离头指针 $ git checkout 9e89670 Note: checking out '9e89670'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b HEAD is now at 9e89670 Python Code 分离头指针后做一些提交 echo \"# Test Code\" > test.py git add test.py && git commit -m \"Test Code\" $ git branch * (HEAD detached from 9e89670) master $ git log --online 57309b9 (HEAD) Test Code 9e89670 Python Code $ git log master --oneline c155d2e (master) Python Document 9e89670 Python Code 若没有此时还未绑定到具体分支 $ git checkout -b fix-1 尝试切换到 master 分支 $ git checkout master 因此，切换 HEAD 最好在分支引用之间！好的一面是，分离头指针可以用作提交实验。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-cherry-pick.html":{"url":"cli/git-cherry-pick.html","title":"git cherry-pick","keywords":"","body":"git cherry-pick 「精心挑选」 在当前分支或某个提交之上，重新应用挑选的已有提交。 Rebase 与 Cherry-pick rebase: 将当前分支相较于目标分支的差异提交（通常是多个）重新应用到目标分支上，最终在目标分支上创建了一个个新的提交（即差异提交的 hash 发生改变） cherry-pick: 将目标分支上的某个提交重新应用到当前分支上，最终在当前分支上创建了一个新的提交（即挑选的提交的 hash 发生改变） Author 与 Committer 当挑选某个开发者的 commit 引用到自己的代码上时，author 将是被挑选者的 name，而 commit 则是自己的 name 。 典型的是，引用了创建 Github 仓库时所创建的 README.md 和 LICENSE 。 范例 git cherry-pick # 把某个分支的一次或几次提交在当前分支上重演（即重新应用），而原来的分支保持不变（可以用来避免了分支合并） git cherry-pick # 单独合并一个提交 git cherry-pick -x # 同上，不同点：保留原提交者信息。 git cherry-pick .. git cherry-pick ^.. 应用场景 当在 A 分支上做了几次 commit 后，发现实际应该在 B 分支上工作，因此需要将 A 分支上的 commit 重新应用到 B 分支上 参考 git cherry-pick 使用指南 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-clean.html":{"url":"cli/git-clean.html","title":"git clean","keywords":"","body":"git clean 从工作区移除未追踪的文件 用例 git clean // fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean git clean -n // \"dry run\"（演习）：显示哪些 unstracked 文件将会被删除（不包括 unstracked 目录），但实际不会将其删除 git clean -f // 删除所有 unstracked 文件（不包括 unstracked 目录），即删除 git clean -n 显示的文件 git clean -xn // 显示哪些 unstracked 文件和 ignored 文件将会被删除，但实际不会将其删除 git clean -dn // 显示哪些 unstracked 文件和目录将会被删除，但实际不会将其删除 git clean -xdn git clean -df // 删除所有 unstracked 文件和目录，即删除 git clean -dn 显示的文件和目录 git clean -xf // 删除所有 unstracked 文件、 ignored 文件，以及 .gitignore 文件 git clean -xdf Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-clone.html":{"url":"cli/git-clone.html","title":"git clone","keywords":"","body":"git clone 使用 git clone 克隆远程仓库时，Git 会自动创建一个名为 “origin” 的指向克隆仓库的远程连接。 用例 用例 描述 git clone --single-branch --branch 克隆远程仓库的特定分支 git clone --depth=N （浅）克隆远程仓库最近 N 次提交历史，通常 N = 1，有利于提升克隆速度 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-commit.html":{"url":"cli/git-commit.html","title":"git commit","keywords":"","body":"git commit 选项 参数 说明 -a 将已追踪文件的修改和删除添加到提交，但不包括新文件 --amend 启动 Git 的默认编辑器修正当前分支最近一次提交的 CommitMessage，并提交暂存区 -m 指定 commit message 。如果是多行，可以不用 -m 用例 用例 描述 git commit --amend 启动 Git 的默认编辑器修正当前分支最近一次提交的 CommitMessage；无论是否有改动，最终都会生成新的 CommitID；该命令会将暂存区中的文件提交 git commit -a --aemond 提交已追踪文件的更改，并启动 Git 的默认编辑器修正当前分支最近一次提交的 CommitMessage；无论是否有改动，最终都会生成新的 CommitID 提交规范 用途： 从 commit 生成 changelog 提交之前： # 统一文件权限 $ find . -type f -not -path .git -exec chmod 644 {} \\; # 常规文件 $ find . -type d -not -path .git -exec chmod 755 {} \\; # 目录 # 末尾添加新行（Git 要求） $ find . -type f -not -path .git -name \"*.md\" -exec sed -i -e '$a\\' {} \\; # Linux $ find . -type f -not -path \"./.git/*\" -name \"*.md\" -exec sed -i '' -e '$a\\' {} \\; # macOS # MacOS 删除 .DS_Store（最好事先添加到 .gitignore） $ find . -type f -not -path .git -name \".DS_Store\" -exec rm {} \\; 技巧 创建 “原子提交” 有利于追踪 BUG 以及回滚 示例 修改最新 commit 的 message git init e1 && cd e1 echo \"README\" > README.md git add . && git commit -m \"README\" $ git log --oneline a9c0935 (HEAD -> master) README $ git commit --amend Document # 修改后的 message # Commit ID 和 message 都不相同 $ git log --oneline b03da2e (HEAD -> master) Document 参考 你可能会忽略的 Git 提交规范 Commit message 和 Change log 编写指南 github.com/tj/git-extras github.com/conventional-changelog/conventional-changelog Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-config.html":{"url":"cli/git-config.html","title":"git config","keywords":"","body":"git config 配置作用域 编号 作用域 描述 配置文件路径 ① git config / git config --local 针对当前使用的仓库 ./.git/config ② git config --global 针对当前用户的所有仓库 ~/.gitconfig 或 ~/.config/git/config ③ git config --system 针对操作系统的每一个用户 /etc/gitconfig 优先级：① > ② > ③ 查看配置 # 所有配置 $ git config --list # 不同作用域的配置 $ git config --list [--local | --global | --system] # 查看某个配置 $ git config user.name $ git config alias.lg 最小配置 $ git config [--global | --local] user.name \"jinsyin\" $ git config [--global | --local] user.email \"jinsyin@gmail.com\" 目的： 标记做出代码变更的用户是谁 评审人员 Code Review 并指出开发者的问题时，代码托管平台可以自动发送邮件通知开发者 关闭文件模式 当文件的模式发送改变（比如从 644 变成了 777）时，Git 默认会把这当做是一次变更，可以使用以下方式关闭： $ git config --global core.filemode false 配置代理 HTTP $ git config --global http.proxy http://127.0.0.1:1070 # 取消 $ git config --global --unset http.proxy SOCKS # socks5h 代替 socks5 $ git config --global http.proxy socks5h://127.0.0.1:1080 # 使用环境变量 $ ALL_PROXY=socks5://127.0.0.1:1080 git clone https://github.com/x/y.git 文本编辑器 $ git config --global core.editor vim 清除配置 $ git config --unset [--local | --global | --system] user.name 格式 $ man git-log # 搜索 format: 格式 描述 %H commit hash %h 缩写的 commit hash 颜色值 第一个或者两者的组合： normal, black, red, green, yellow, blue, magenta, cyan and white bold, dim, ul, blink and reverse 或者直接使用颜色值，如 #17b062。 MacOS 大小写 macOS 的默认文件系统不区分大小写但保留大小写（Linux 的文件系统区分大小写），所谓 “保留大小写” 指的是创建了 readMe 得到依然是 readMe 。 换句话说，readme 和 README 不可能同时存在（因为它们被看作是同一文件），它们在 Git 可以不同时存在（也就是分不同批次进行提交）， # 让 Git 区分大小写（每个仓库可能情况不一样） $ git config core.ignorecase false # 让 Git 不区分大小写（每个仓库可能情况不一样） $ git config core.ignorecase true 参考 How to: Colours in Git Git Alias Git 设置和取消代理 git config Duplicated file with different case in git origin (bitbucket) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-diff.html":{"url":"cli/git-diff.html","title":"git diff","keywords":"","body":"git diff Show changes between commits, commit and working tree, etc（比较三个工作区域中两两之间的文件差异） 用法 git diff [] [] [--] [...] git diff [] --cached [] [--] [...] git diff [] [--] [...] git diff [] git diff [] --no-index [--] 命令详解 参数 描述 git diff [--options] [--] [...] 比较工作区和暂存区之间 某些/所有 文件的差异 git diff [--options] --cached [] [--] [...] 比较暂存区和 Git 仓库之间 某些/所有 文件的差异 git diff [--options] [--] [...] 比较工作区和 Git 仓库之间 某些/所有 文件的差异 用例 git diff // 对比工作区所有文件相对于暂存区所做的更改 git diff [--] ... // 对比工作区某些文件相对于暂存区所做的更改 git diff -- ... // 对比两个提交或两个分支之间某些文件的差异（后一个相对于前一个） git diff --cached HEAD []/ git diff --staged [paths] // 比较暂存区文件与版本库文件之间的差异 git diff HEAD -- [] // 比较工作区文件与版本库文件之间的差异 git diff --name-only SHA1 SHA2 // 只对比文件名称 git diff stash@{0} otherbranch@{0} 区域 diff --git a/diff_test.txt b/diff_test.txt // comparison input index 6b0c6cf..b37e70a 100644 // metadata --- a/diff_test.txt // Markers for changes +++ b/diff_test.txt // Markers for changes @@ -1 +1 @@ // Diff chunks -this is a git diff test example // Diff chunks +this is a diff example // Diff chunks 实验一 · 比较暂存区与最近一次提交的差异 git init e1 && cd e1 echo \"Web\" > README.md && git add . && git commit -m 'Web' echo \"\" > index.html && git add . && git commit -m 'Home page' echo \"# Web\" > README.md && git add . echo \"123\" > index.html && git add . $ git status modified: README.md # 最近一次提交相对于暂存区做了哪些修改 # 缺省 HEAD 时默认是 HEAD，缺省 README.md 时默认是比较所有文件 $ git diff --cached [HEAD] [README.md] diff --git a/README.md b/README.md index eae45af..76912a2 100644 --- a/README.md +++ b/README.md @@ -1 +1 @@ -Web +# Web Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-difftool.html":{"url":"cli/git-difftool.html","title":"git difftool","keywords":"","body":"git difftool 启动外部工具展示两棵树之间的差异。 设置 DIFF 工具 $ git config --global diff.tool vimdiff 示例 $ git diff -y --tool=vimdiff x.md Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-fetch.html":{"url":"cli/git-fetch.html","title":"git fetch","keywords":"","body":"git fetch 从其他仓库下载对象（objects）和引用（refs） git fetch 命令从远程仓库拉取提交到本地仓库，提交结果被存储在远程分支，而不是本地分支，所以它不会对本地开发工作产生影响。 选项 选项 描述 -p 拉取远程分支之前，移除已经不存在于远程但还存在于本地的远程追踪分支，如 origin/temp 远程分支 远程分支可以看作是只读分支。 用法 # 从远程仓库中拉取所有分支 $ git fetch # 拉取指定分支 $ git fetch Examples $ git branch -v -a 2.3.0 05b56ff Spark 2.3.0 * master 05b56ff Spark 2.3.0 # 拉取远程 $ git fetch origin master $ git branch -v -a 2.3.0 05b56ff Spark 2.3.0 * master 05b56ff Spark 2.3.0 remotes/origin/master bb01475 Initial commit 参考 https://www.atlassian.com/git/tutorials/syncing Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-grep.html":{"url":"cli/git-grep.html","title":"git grep","keywords":"","body":"git grep 输出匹配某个模式的文本行 用法 git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp] [-v | --invert-match] [-h|-H] [--full-name] [-E | --extended-regexp] [-G | --basic-regexp] [-P | --perl-regexp] [-F | --fixed-strings] [-n | --line-number] [--column] [-l | --files-with-matches] [-L | --files-without-match] [(-O | --open-files-in-pager) []] [-z | --null] [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet] [--max-depth ] [--[no-]recursive] [--color[=] | --no-color] [--break] [--heading] [-p | --show-function] [-A ] [-B ] [-C ] [-W | --function-context] [--threads ] [-f ] [-e] [--and|--or|--not|(|)|-e ...] [--recurse-submodules] [--parent-basename ] [-W | --function-context] [--threads ] [-f ] [-e] [--and|--or|--not|(|)|-e ...] [--recurse-submodules] [--parent-basename ] [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | ...] [--] [...] 用例 用例 描述 git grep \"xxx\" 在工作区的 tracked 文件中查找指定模式 git grep -Ii --line-number 忽略大小写、显示匹配行的行号 git grep --cached \"xxx\" 在暂存区中搜索指定模式 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-lfs.html":{"url":"cli/git-lfs.html","title":"git lfs","keywords":"","body":"git lfs Git Larget File Storage （LFS） GitHub 默认不能上传超过 50MB 的文件, 所以需要使用 Git LFS, 它支持存储将大文件存储在远程服务器. 前提：Git 版本大于等于 v1.8.5 安装 Git 默认是没有 git lfs 命令支持的，需要安装 Git LFS. Debian/Ubuntu # sudo $ curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash # 添加 repo $ apt-get update $ apt-cache policy git-lfs $ apt-get install git-lfs # 最新版 https://packagecloud.io/github/git-lfs/install 安装好之后,需要手动初始化 $ git lfs install 通过 Git LFS 添加所有 zip 文件,匹配的文件将被放在 .gitattributes 中 $ git lfs track \"*.zip\" 提交到本地仓库 $ git add .gitattributes $ git add my.zip $ git commit -m \"add zip\" 查看,确认 $ git lfs ls-files 提交到远程仓库 $ git push origin master 参考文章 https://git-lfs.github.com/ https://github.com/git-lfs/git-lfs Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-log.html":{"url":"cli/git-log.html","title":"git log","keywords":"","body":"git log 显示提交日志 命令详解 # 帮助文档 $ git help [--web] log 参数 描述 示例 master / [空] 显示 master 分支的提交历史 git log [分支名] 显示特定分支的提交历史 git log dev --oneline 按行显示每一次的提交历史 git log --oneline -n [数字] / -[数字] 显示最近的 N 次提交历史 git log -2 --all 显示所有分支的提交历史 git log --all --graph 图形化显示提交历史；组合 --all 参数可以直观地查看分支间的分叉关系 git log --all --graph --stat 格外显示每次提交的文件 -S [关键字] 从提交日志中全文检索关键字 git log -S README -p [文件名] 比较指定文件在所有提交历史中的差异 git log -p README.md --follow [文件名] 按行列出哪里提交涉及了该文件，包括重命名该文件而涉及的历史记录（默认不包括）；可以和 -p 一起使用 git log --follow README.md $ git config alias.lg log --color --graph --abbrev-commit --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' 用例 命令 描述 git log --oneline 按行显示当前分支的提交历史（hash + message） git log --oneline origin/master 按行显示远程（origin）master 分支的提交历史（hash + message） git log --oneline --all --graph 按行显示所有分支的提交历史，并使用文本图形来显示分叉关系 git log --oneline [--] 按行列出哪里提交涉及了该文件（不包括重命名文件） git log --oneline --follow [--] 按行列出哪里提交涉及了该文件，包括重命名该文件而涉及的历史记录 git log --oneline --stat 统计该提交或引用到第一次提交的信息 格式选项 git log --pretty=format 常用的选项： 选项 描述 %H commit 对象的完整哈希字符串 不同用户的提交 $ git shortlog $ git shortlog -sn # 显示所有提交过的用户，按提交次数排序 $ git blame [file] # 显示指定文件是什么人在什么时间修改过 查看某次提交的变化 $ git show [commit] # 内容变化 $ git show --name-only [commit] # 查看哪些文件发生了变化 查看提交和回滚历史 $ git reflog Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-ls-files.html":{"url":"cli/git-ls-files.html","title":"git ls-files","keywords":"","body":"git ls-files 显示暂存区和工作区中文件的信息 用法 git ls-files [-z] [-t] [-v] [-f] (--[cached|deleted|others|ignored|stage|unmerged|killed|modified])* (-[c|d|o|i|s|u|k|m])* [--eol] [-x |--exclude=] [-X |--exclude-from=] [--exclude-per-directory=] [--exclude-standard] [--error-unmatch] [--with-tree=] [--full-name] [--recurse-submodules] [--abbrev] [--] [...] 选项 选项 描述 -c、--cached 显示暂存的文件（默认） -d、--deleted 显示删除的文件 -m、--modified 显示修改的文件 -o、--others 显示未追踪的文件 -s、--stage --unmerged Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-ls-tree.html":{"url":"cli/git-ls-tree.html","title":"git ls-tree","keywords":"","body":"git ls-tree 列出 tree 对象的内容 用法 git ls-tree [-d] [-r] [-t] [-l] [-z] [--name-only] [--name-status] [--full-name] [--full-tree] [--abbrev[=]] [...] Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-merge.html":{"url":"cli/git-merge.html","title":"git merge","keywords":"","body":"git merge 「三方合并」 将两个或多个开发历史（通常是分支）连接在一起。 用法 git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit] [-s ] [-X ] [-S[]] [--[no-]allow-unrelated-histories] [--[no-]rerere-autoupdate] [-m ] [-F ] [...] # 只能在合并导致冲突后运行 # 将中止合并进程，并尝试重建预合并状态。但是如果在合并开始是有未提交的更改（尤其是在合并开始后进一步修改了这些更改），则它在某些情况下将无法重建原始（预合并）更改，因此：警告：不鼓励使用不重要的未提交更改运行git merge：如果可能，它可能会使您处于一种在发生冲突时很难退出的状态。 git merge --abort # 只能在合并导致冲突后运行 git merge --continue 选项 选项 描述 --ff 快进（fast-forward）合并（默认行为）：如果没有分叉，直接向前移动分支的指针，不会创建新的提交对象 --no-ff 无论提交历史是否存在分叉，都将创建一个新的提交对象 --ff-only 只允许快进合并 描述 将命名提交的更改（从其历史记录与当前分支分离是起）合并到当前分支。git pull 使用此命令合并来自另一个仓库的更改，以及可以手动将一个分支的更改合并到另一个分支。 A---B---C topic A---B---C topic / git merge topic / \\ D---E---F---G master(HEAD) -------------------> D---E---F---G---H master(HEAD) 合并结果会记录在新的 commit （即图中的 H），换而言之，合并后会产生一个新的提交 原理（三方合并）： 找到两个分支（即当前分支和待合并分支）的最近共同祖先 E 两个分支的最新快照（C 和 G）以及二者最近的共同祖先 E 进行三方合并 合并结果生成一个新的快照（H）并提交 快进合并流程 A---B---C topic A---B---C topic master(HEAD) / git merge topic / D---E---F---G master(HEAD) -------------------> D---E---F---G 前提： 位于 之后且不存在分叉 切换到更早的分支：git checkout 合并：git merge （等同于 git merge --ff ） 合并完成后 和 指向同一个 commit 对象 如无其他需求，删除 ：git branch -d 冲突 呈现 解决 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-mv.html":{"url":"cli/git-mv.html","title":"git mv","keywords":"","body":"git mv 转移或重命名一个文件、目录或软连接 重命名文件 （假设要将 README 重命名为 README.md） 方法一： git mv README README.md 方法二： mv README README.md git rm README git add README.md 方法三： mv README README.md git add README README.md Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-pull.html":{"url":"cli/git-pull.html","title":"git pull","keywords":"","body":"git pull 获取且合并另一个仓库或者本地分支 帮助 $ man git-pull $ git pull --help 用法 git pull [] [ [...]] 选项 选项 描述 -r、`--rebase[=false true merges preserve interactive]` 描述 将远程仓库的更改合并到当前分支。在默认模式中，git pull = git fetch + git merge FETCH_HEAD。 A---B---C master on origin A---B---C origin/master / git pull / \\ D---E---F---G master ===========> D---E---F---G---H master ^ origin/master in local repository 对比 - 描述 git pull git pull = git fetch + git merge git pull --rebase git fetch + git rebase；建议使用后者代替前者，避免误操作，比如少打了一个 --rebase git rebase 顾名思义就是重新定义（re）起点（base）的作用，即重新定义分支的版本库状态 git merge Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-push.html":{"url":"cli/git-push.html","title":"git push","keywords":"","body":"git push 更新远程引用（即分支）以及关联对象。 用法 git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=] [--repo=] [-f | --force] [-d | --delete] [--prune] [-v | --verbose] [-u | --set-upstream] [-o | --push-option=] [--[no-]signed|--signed=(true|false|if-asked)] [--force-with-lease[=[:]]] [--no-verify] [ [...]] 选项 选项 描述 -u、--set-upstrem 设置、关联当前分支的上游分支 -f、--force 用例 用例 描述 git push origin master 将本地仓库中的 master 引用（即本地的 refs/heads/master）更新到 origin 仓库中的同名（即 master）引用（即 origin 的 refs/heads/master）；等同于 git push origin master:master git push origin HEAD 将当前分支更新到远程同名的分支 git push origin HEAD:master 将当前分支更新到远程 origin 仓库的 master 分支，不考虑本地当前分支的名称 git push origin omaster:master 将本地的 omaster 分支推送到远程 origin 的 master 分支 git push origin :experimental 删除远程 origin 仓库的 experimental 分支（相当于将本地空分支更新到远程 experimental 分支） git push origin dev test 将本地的 dev 、test 分支更新到远程 origin 仓库，并保持同名；等同于 git push origin dev:dev test:test git push origin --all 推送本地的所有分支到远程 origin 仓库，并保持分支名一致 git push -f origin 93667ed1:feature 将本地的 93667ed1 提交强制推送到远程 origin 的 feature 分支 git push -u origin master:upbranch 关联当前分支的上游分支（只需要在第一次推送或者需要修改时进行设置，省略 upbranch 代表上游分支使用相同的名称，另外可以通过 .git/config 查询关联情况），并推送当前分支的提交到上游分支 移除远程分支 $ git fetch origin # 首先同步所有远程分支 $ git push origin --delete testbranch # 或 git push origin :testbranch Github 可以在 https://github.com///branches 页面点击按钮进行删除。 设置当前分支的上游分支 # 使用 git remote show origin 查看上游分支 $ git push --set-upstream origin dev # git push origin dev 将自动关联上游分支 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-rebase.html":{"url":"cli/git-rebase.html","title":"git rebase","keywords":"","body":"git rebase 「变基」 「变基」：在另一个基础提交之上重新应用提交（Reapply commits on top of another base tip）。换而言之，在基分支上重演，最终基分支不变，当前分支被更新 GitRebase 出错时 Git 很可能处于分离头指针状态 用法 git rebase [-i | --interactive] [] [--exec ] [--onto ] [ []] # ① git rebase [-i | --interactive] [] [--exec ] [--onto ] --root [] # ② git rebase --continue | --skip | --abort | --quit | --edit-todo | --show-current-patch # ③ 选项 参数 描述 -i, --interactive 交互模式 --amend 相当于 git rebase -i HEAD~1 的 edit 行为；如果需要修订非最近一次提交，采用 git rebase -i 的 reword 或 edit 等行为 式③ 参数 描述 git rebase --continue 修复完冲突后运行此命令 git rebase --abort 放弃合并，回到 rebase 之前的状态，不会丢弃之前的提交 git rebase --skip 直接丢弃引起冲突的 commit/patch；或者解决冲突后完成了自我提交（git commit [--amend] ...），之后需要跳过 对于 git rebase --skip，当 Patch 与 HEAD 出现冲突时，如果解决冲突时所有冲突文件 将 全部采用 HEAD 的内容，即使按照此方式依次解决了冲突再 git add ..，最后使用 git rebase --continue 仍然会提示 “No changes”，这是应该使用 git rebase --skip 而不是 git rebase --continue。如果一开始就是跳过，下一个 Patch 时可能还会遇到该问题。 描述 A---B---C topic (HEAD) [git rebase master] A'--B'--C' topic (HEAD) / ----------------------------> / D---E---F---G master [git rebase master topic] D---E---F---G master 「变基（rebasing）」： 找到两个分支（即源当前分支 topic 和目标基底分支 master）的最近共同祖先 E 提取源当前分支相对于祖先 E 的历次提交，并将其另存为临时文件 将当前分支（HEAD）指向目标基底 G，并将之前临时文件的一系列提交按原有次序依次应用到该分支上，HEAD 随着应用的提交逐步更新 整个过程中，基底分支不会发生变化，而源当前分支会随之更新到基底分支的主干上，因此 “变基” 之前最好对源当前分支进行备份 交互模式 命令：git rebase -i START_COMMIT END_COMMIT 行格式： // 从上到下排序、从上到下执行 // 如果删除某一行，该提交将被丢弃 // 如果删除所有行，rebase 将被终止（abort） (action) (partial-sha) (short commit message) 交互行为： 行为（action） 描述 p、pick 使用该 commit，但不做任何修改（默认行为） r、reword 使用该 commit 以修改其 commit message，但是 commit hash 会发生改变 e、edit use commit, but stop for amending s、squash 使用该 commit，但合并到之前的提交 f、fixup like \"squash\", but discard this commit's log message x、exec run command (the rest of the line) using shell d、drop remove commit 交互流程： 交互前对源当前分支进行备份（git branch ），防止交互结果不理想 交互前如果工作区和/或暂存区存在修改，需要进行储藏（git stash save -u \"...\"） git rebase -i 合并时 HEAD 指向 START_COMMIT，意味着整个过程将一直处于无分支（即分离头指针）状态 在编辑视图中，Commit 对象的范围是：(START_COMMIT, END_COMMIT]，END_COMMIT 的缺省值是 HEAD 合并时如果 END_COMMIT 不是 HEAD，合并完成后将依然处于无分支状态，最终 HEAD 指向 END_COMMIT（该方式意义不大） 通常是将 END_COMMIT 设置为 HEAD，对于 (END_COMMIT, HEAD] 之间不需要修改的 commit 直接设置为 pick 行为 交互过程中，可以随时终止：git rebase --abort，最终回到原来的分支 Git 将启动默认编辑器，根据需求编辑相关行为（action）然后保存 如果要使用 squash 行为，必须确保前一个提交的行为是 pick，所以可能需要手动添加一个 pick 行或者移动一个 pick 行 如何直接编辑行为外，还可以移动、添加一个 ”提交行“ 保存行为后 Git 会根据相关行为自动应用提交 squash 行为且无冲突，会再次启动编辑器，需要编辑合并的 commit 信息 解决冲突的办法（使用 git diff ... 或 diff [-r] 定位冲突标记，以及使用 git grep ' 查找冲突文件） 编辑、删除冲突文件和其他（如新增、删除文件） -> git add -> git rebase --continue，其中 git add 就是告知 Git 冲突已被解决 编辑、删除冲突文件和其他（如新增、删除文件） -> git add -> git commit -m \"message\" -> git rebase --skip，也就是自行完成提交以修改 Patch 的 commit message 编程、删除冲突文件和其他（如新增、删除文件） -> git add -> git commit --amend，也就是将解决好的冲突并入最近一次提交 放弃解决冲突，选择直接跳过：git rebase --skip 重新应用提交会从 START_COMMIT 开始生成新的 CommitID 比较新当前分支与备份分支之间的差异，看看结果是否理想。如果合并没有问题，记得删除备份分支：git branch 如果结果满意，可以恢复之间工作区和暂存区的内容：git stash pop 0 交互技巧： 如果要合并两个或多个离散的 commit，需要移动 commit 的位置并使之连续，然后再设置相应的行为 如果要使用第一个 commit，可以在 git rebase -i 进入交互模式后在第一行手动添加 pick 完成交换操作后，当前 commit ID 及其之后的 commit ID 通常会改变，而日期不会发生改变 commit 的范围是 (x, y]，如果需求是合并（squash、fixup 等），至少需要选择被合并的 commit 前两个的 commit；如果需求是编辑（edit、reword 等），至少要选择需要被编辑的 commit 的前一个 commit 合并/变基流程 变基前暂存区不能存放内容 合并前对源分支进行备份（git branch ），以免合并结果不理想 合并（git rebase ） 它将从目标分支（即基分支）和源分支的分叉点开始，自动在基分支上依次应用分叉点到源分支上的每一个 commit（亦称 patch），并且 CommitID 会发生改变 整个合并过程一直处于无分支（no branch）/分离头指针（detached HEAD）状态，HEAD 指向基分支上最近一次应用成功的 commit（最开始时指向基分支） 应用的 Rebase 信息位于 .git/rebase-apply/ 目录 合并过程中，可以随时终止合并：git rebase --abort，最终回到原来的分支 如果有冲突，GitRebase 将停在有冲突的 commit/patch 处（即 incoming commit），冲突提示显示在 git status 的 “Unmerged paths” 区域 解决冲突的方法同 ”交互流程“，不同的可能是 ”冲突提示“，解决完冲突之后，Git 会继续 Rebase 进程，以应用下一个的 commit 遇到冲突时可以查看 Patch 信息：git am --show-current-patch 需要注意的是，此处的 Patch 不是 incoming commit 相当于目标分支上 HEAD 所做的修改，而是 incoming commit 在源分支上相对于前一个 commit 所在的修改，因此参考的意义基本在于查看 Patch 的 commit id 和 commit message 如果要查看 incoming commit 相对于 HEAD 做的修改，可以：git diff HEAD 可以使用 git diff HEAD -- 比较暂存区与版本库的差异 可以使用 git diff --cached HEAD [] 比较暂存区与版本库的差异 解决完冲突并 GitAdd 之后，应当对比暂存区和 HEAD（git diff --cached HEAD [...]），以及 Patch 的 commit message（git am --show-current-patch），看看是否前后内容满意 如果对此次的 Patch 或者 commit message 不满意，可以自行进行一次提交（git commit -m ....）或合并到最近一次提交（git commit --amend），然后直接跳过 Patch git rebase --skip（或者不自行提交和合并到最近一次提交，直接跳过，但可能下一个 incoming commit 还会遇到） 如果觉得符合，继续下一个 patch：git rebase --continue 冲突时，可能已经有文件被自动添加到了暂存区，一定要先检查暂存区的文件是否是需要的! 合并完成后两个分支变为一个分支，目标分支保存不变，原先的源分支被应用到目标分支上且分支名不变，最终 HEAD 指向新的 比较新当前分支与备份分支之间的差异，看看结果是否理想。如果合并没有问题，记得删除备份分支：git branch 冲突提示 “冲突提示” 显示在 git status 的 “Unmerged paths” 区域。 冲突提示 描述 both added incoming commit 和 HEAD 都新建了同一文件且存在冲突 both modified incoming commit 和 HEAD 都修改了同一文件且存在冲突 both deleted incoming commit 和 HEAD 都删除了同一文件 added by us HEAD（即 us） 相对于 incoming commit 所添加的文件 deleted by us HEAD（即 us） 删除了该文件，但 incoming commit 又增加了该文件 added by them incoming commit（即 them） 相对于 HEAD 所添加的文件 deleted by them incoming commit（即 them） 相对于 HEAD 所删除的文件 采用 HEAD 的内容：git checkout --ours 采用 incoming commit 的内容：git checkout --theirs rm-bd = !git status | grep 'both deleted' | awk '{print $3}' | xargs git rm rm-abus = !git status | grep 'added by us' | awk '{print $4}' | xargs git rm rm-abthem = !git status | grep 'added by them' | awk '{print $4}' | xargs git rm rm-dbus = !git status | grep 'deleted by us' | awk '{print $4}' | xargs git rm add-abus = !git status | grep 'added by us' | awk '{print $4}' | xargs git add add-abthem = !git status | grep 'added by them' | awk '{print $4}' | xargs git add add-dbus = !git status | grep 'deleted by us' | awk '{print $4}' | xargs git add // 被我们删除，incoming commit 有添加了回来 相对于 incoming commit 的上一次 commit 所做的修改，而不是相对于 HEAD； 可以使用 git diff HEAD -- 比较暂存区与版本库的差异 可以使用 git diff --cached HEAD [] 比较暂存区与版本库的差异 当 patch 相对于 HEAD 没有作任何修改是，可以直接跳过 git rebase --skip 实验场景一 · 合并多个连续的 commit 成 1 个 git init e1 && cd e1 echo \"Web\" > README && git add . && git commit -m \"Add README\" echo \"\" > index.html && git add . && git commit -m \"Home page\" mkdir js && touch js/script.js && git add . && git commit -m \"Add js\" mkdir css && touch css/style.js && git add . && git commit -m \"Add css\" git mv README README.md && git commit -m \"rename README to README.md\" $ git log --oneline --graph * e6706f9 (HEAD -> master) rename README to README.md * 0a12fcd Add css * 17b0128 Add js * f9bfb66 Home page * fb7cb97 Add README # 基于第一个提交（可以写成 HEAD~n 形式） $ git rebase -i fb7cb97 # (startCommit, endCommit]，缺省 endCommit 时默认是 HEAD （即最近一次提交） ``` # 将 #3 和 #4 合并到 #2 （使用 squash 必须确保前一个提交为 pick） p f9bfb66 Home page #2 （base tip 必须是 pick） s 17b0128 Add js #3 s 0a12fcd Add css #4 p e6706f9 rename README to README.md #5 ```` ``` # 修改 commit message Web frontend ``` $ git log --oneline --graph * 94576fb (HEAD -> master) rename README to README.md * a2cd20e Web frontpage * fb7cb97 Add README 实验场景二 · 把几个间隔的 commit 整合成 1 个 根据实验一，合并 94576fb 和 fb7cb97 为 1 个 commit： $ git rebase -i fb7cb97 # (fb7cb97, HEAD] ``` pick fb7cb97 # 手动添加 base tip s 2a50998 rename README to README.md # 改变顺序并合并到 base tip pick 4ad2f07 Web frontend ``` ```sh $ git rebase --continue README # 修改后的 commit message ``` ```sh $ git log --oneline --graph * 2c84512 (HEAD -> master) Web frontend * 5f0c43a README ``` # 希望将 #1 和 #2 合并为一个提交 $ git lg * 2019-09-12 4102626 - (HEAD -> master) 文档及项目文档 [jinsyin] #1 * 2019-09-12 ab35fcb - Extended Node.js [jinsyin] * 2019-09-12 0ae3841 - Extended Java [jinsyin] * 2019-09-12 9f886a6 - Extended Go [jinsyin] * 2019-09-12 b85b0fc - Extended scala [jinsyin] * 2019-09-12 cc1eb9f - Extended Python [jinsyin] * 2019-05-06 00f95af - (origin/master, origin/HEAD) Initial commit [GitHub] #2 $ git rebase -i 00f95af pick 00f95af # 手动添加 base tip s 00f95af 文档及项目文档 pick cc1eb9f Extended Python ... $ git rebase --continue # 遇到冲突解决冲突，直到完成 实验场景三 · 拆分提交 参考 Git 之 交互式 rebase Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-reflog.html":{"url":"cli/git-reflog.html","title":"git reflog","keywords":"","body":"git reflog 执行 git rebase --abort 会丢失一些 commit，git reflog 可以查看所有 commit 日志。 路径： .git/logs/HEAD .git/logs/refs/stash .git/logs/refs/heads/ .git/logs/refs/remotes/ 用例 git reflog show --all git reflog show HEAD git reflog show otherbranch git reflog stash Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-remote.html":{"url":"cli/git-remote.html","title":"git remote","keywords":"","body":"git remote 远程仓库默认名为 origin。 查看远程仓库 $ git remote -v # 查看所有远程仓库 $ git remote show [remote] # 查看指定远程仓库 添加远程仓库 $ git remote add [remote] [url] # git remote add origin git@github.com:jinsyin/learn-git.git 同步远程 $ git fetch [remote] [branch] # 获取远程某分支的最新版本，但不会自动合并与本地当前分支合并 $ git fetch [remote] # 获取远程所有分支的最新版本，但不会自动合并与本地分支合并 # git pull origin master == (git fetch origin master && git merge origin/master) $ git pull [remote] [branch] # 获取远程某分支的最新版本，并与本地当前分支合并。合并后，工作区同步版本库 推送分支 $ git push [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] --force # 强行推送当前分支到远程仓库，远程仓库会被完全覆盖 $ git push [remote] --all # 推送所有分支到远程仓库 示例 $ git remote show origin * remote origin Fetch URL: git@github.com:JinsYin/cloud-native-handbook.git Push URL: git@github.com:JinsYin/cloud-native-handbook.git HEAD branch: master Remote branches: application tracked master tracked Local refs configured for 'git push': application pushes to application (up to date) master pushes to master (local out of date) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-rerere.html":{"url":"cli/git-rerere.html","title":"git rerere","keywords":"","body":"git rerere Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-reset.html":{"url":"cli/git-reset.html","title":"git reset","keywords":"","body":"git reset git add 和 git reset 是两个相反的操作，而 git commit 则提交暂存区的快照到版本库 用法 git reset [-q] [] [--] ... # ① 撤销暂存区 git reset (--patch | -p) [] [--] [...] # ② git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [] # ③ 回滚历史 式 ① 将暂存区的所有 重置为 时的状态（这不会影响工作区或当前分支），并将暂存区 的修改放回到工作区。 git reset = git reset -- = git reset HEAD -- 意味着 git reset 与 git add 是两个相反的操作 此命令相当于 git restore [--source=] --staged ... 式 ② 式 ③ 以下都可以回滚到历史提交，但有所不同： 子命令 是否重置工作区（删除工作区改动） 是否重置暂存区（撤销 git add） git reset --soft [] No No git reset --mixed [] / git reset [] No Yes git reset --hard [] Yes Yes 注：如果上述三个命令不提供具体的文件名，将重置所有，否则将重置具体的文件。 用例 git reset [HEAD] [--] [...] // 撤销暂存区文件的更改（快照），并使暂存区文件的状态与 HEAD 保持一致，相当于撤销 git add [...] git reset --hard 误操作后如何恢复工作区 以下操作只能恢复执行过 git add 操作的 Git 对象，对于没有执行过该操作的对象无能为力。 查询前 10 次 Git 对象 $ find .git/objects -type f | xargs ls -lt | sed 10q -r--r--r-- 1 yin yin 25119 1月 21 15:44 .git/objects/dd/cd84c64958bc5c42ee63f53bf47ee79e058cc5 -r--r--r-- 1 yin yin 120 1月 21 15:44 .git/objects/1e/76912a7aef5e6151a5d59b73c834d60577bdd7 -r--r--r-- 1 yin yin 54 1月 21 15:44 .git/objects/1e/a5907733b5db088d42be5953c5ca4cb844fe69 -r--r--r-- 1 yin yin 104 1月 21 15:44 .git/objects/25/076c5104aaa47e260e54031efcf254108f3201 -r--r--r-- 1 yin yin 54 1月 21 15:44 .git/objects/63/4b8a1188c3b1f90c9c690cc21433b48fd6755e -r--r--r-- 1 yin yin 60 1月 21 15:44 .git/objects/7a/79ea64c675170efd0cc985ec573e32bee765c5 -r--r--r-- 1 yin yin 737 1月 21 15:44 .git/objects/7a/ed33ecfc8ac1161cfc00145a42307b8a552c49 -r--r--r-- 1 yin yin 152 1月 21 15:44 .git/objects/7e/cd053f8e49a821360961d142689b39c1cffa71 -r--r--r-- 1 yin yin 238 1月 21 15:44 .git/objects/c1/e72f553de27452532939bfad64598d498df801 -r--r--r-- 1 yin yin 65 1月 21 15:44 .git/objects/2e/14ac9551a2b122c4293bb3185bec90b9f6dde6 判断 Git 对象的类型 # SHA 值取自上一命令的最后两个路径 dd/cd84c64958bc5c42ee63f53bf47ee79e058cc5 （也可以只取一部分，如：ddcd84） $ git cat-file -t ddcd84c64958bc5c42ee63f53bf47ee79e058cc5 blob # 树（tree）对象可以引用一个或多个块（blob）对象或其他 tree 对象，每个 blob 对象对应一个文件 $ git cat-file -t 1e76912a7aef5e6151a5d59b73c834d60577bdd7 tree 查看树的内容 # 如果是 tree 类型的对象 $ git ls-tree 1e76912a7aef5e6151a5d59b73c834d60577bdd7 100644 blob 5d24bd7030066f9860a440eb64ea889654353ee2 README.md 100644 blob b77b483d5ff120961d7860599baa63941d1272e7 bridge.md 100644 blob c0353930f6e99afc97c3b54f776f9f62a2215558 l2-switch.md 查看 blob 对象的内容 # 确保 SHA 值对应的类型是 blob 而不是 tree、commit 或 tag（结果可能是文本，也可能是图片等二进制文件） $ git cat-file blob 5d24bd7030066f9860a440eb64ea889654353ee2 # > x.md $ git cat-file blob ddcd84c64958bc5c42ee63f53bf47ee79e058cc5 # > x.png 参考 查看 Git 对象 恢复 git reset --hard 删除的文件 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-restore.html":{"url":"cli/git-restore.html","title":"git restore","keywords":"","body":"git restore 恢复/还原工作区或暂存区的文件，即丢弃工作区、或者撤销暂存区的修改并使之放回到工作区。 git restore = git checkout -- // 丢弃工作区的修改 git restore --staged = git reset HEAD // 撤销暂存区文件的修改，使之放回到工作区 GitRestore 是 Git 新版本增加的命令，个人猜测是为了取代 git checkout -- 和 git reset HEAD ，从而避免混淆。 用法 git restore [] [--source=] [--staged] [--worktree] ... git restore (-p|--patch) [] [--source=] [--staged] [--worktree] [...] 选项 选项 描述 -W、--worktree、-S、--staged 指定恢复路径。如果两个选项都未指定，则默认将还原工作区。指定 --staged 仅还原暂存区。两个选项都指定则工作区和暂存区都还原 git restore = git restore --worktree ... Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-revert.html":{"url":"cli/git-revert.html","title":"git revert","keywords":"","body":"git revert 恢复一些已经存在的提交 用法 git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[]] ... git revert --continue git revert --quit git revert --abort Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-rm.html":{"url":"cli/git-rm.html","title":"git rm","keywords":"","body":"git rm 从工作区和暂存区移除文件，不包括未追踪的文件。 撤销 git rm：git rm 不是一个永久的更新。在新的提交被创建之前这些更改不会被持久化 参数 描述 git rm --cached 仅从暂存区删除 git rm -f/--force 选项 -n / --dry-run 用例 git rm // 同时删除暂存区和工作区的文件 git rm --cached // 只删除暂存区的 tracked 文件。删除之后工作区的该文件变为 untracked 状态 git rm 没有选项能够只移除工作区的文件 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-show-branch.html":{"url":"cli/git-show-branch.html","title":"git show-branch","keywords":"","body":"git show-branch 显示分支及其提交 示例 $ git show-branch Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-show.html":{"url":"cli/git-show.html","title":"git show","keywords":"","body":"git show 显示 Git 对象的类型。 用法 git show [] [...] 参数 参数 描述 要显示的对象名称（默认是 HEAD） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-stash.html":{"url":"cli/git-stash.html","title":"git stash","keywords":"","body":"git stash 「储藏」 将工作区和暂存区的修改储藏（stashing）到 “脏工作区”（dirtry working directory）（不包括为追踪的文件），以记录工作区和暂存区的当前状态，从而得到一个干净的工作区（还原到 HEAD commit）。 GitStash 获取工作区的中间状态（即修改过的被追踪文件和暂存区的变更），并将其保存到一个未完结变更的堆栈中（简称 「储藏区」），以后随时可以重新应用。 用法 git stash list [] # ① git stash show [] # ② git stash drop [-q|--quiet] [] # ③ git stash ( pop | apply ) [--index] [-q|--quiet] [] # ④ git stash branch [] # ⑤ git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet] # ⑥ [-u|--include-untracked] [-a|--all] [-m|--message ] [--] [...]] # git stash = git stash push git stash clear # ⑦ git stash create [] # ⑧ git stash store [-m|--message ] [-q|--quiet] # ⑨ 式④ git stash pop = git stash pop 0 = git stash pop stash@{0} git stash pop [] = git stash apply [] && git stash drop [] 式⑥ git stash // stash 已追踪的文件 git stash -u/--include-untracked // 同上 + stash 未追踪的文件 git stash -a/--all // 同上 + stash 被 .gitignore 忽略的文件 技巧 切换或者合并分支之前，要么 GitStash，要么 GitCommit，否则不能切换或合并分支 在某个分支上储藏的变更可以重新应用到另一个分支上 使用 GitStash 时，一定要记录 stashing 时所在的分支（默认会记录 “wip on branchname…”），以便将储藏的变更应用到合适的分支上 取消储藏（Un-applying a Stash） 在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。 # 可以通过取消该储藏的补丁来实现 $ git stash show -p stash@{0} | git apply -R 用例 git stash save \"....\" // stash 并自行添加注释 git stash list // 列出；从上到下：栈顶 -> 栈底 git stash apply stash@{N} // 应用储藏的某个 stash，但不移除 git stash pop stash@{N} // 应用储藏的某个 stash，并移除之 git stash drop stash@{N} // git stash show // 显示 stash 内容与创建 stash 时的大体差异 git stash show -p // 显示 stash 内容与创建 stash 时的完整差异 git stash branch // 基于 stash 创建分支并自动切换到该分支 git stash clear // 清除所有 stash 示例 建议 ``` * git stash list 默认情况下，stash 被列为 “wip on branchname…”，但创建 stash 时，可以在命令行上给出更具描述性的消息。 ```sh $ git stash list stash@{0}: WIP on (no branch): bb2c8a6 设计理论和设计模式 # 栈顶 stash@{1}: WIP on master: 7013644 Kubernetes 入门教程 # 栈底 git stash show $ git stash show 0 README.md | 2 +- bigdata/spark/README.md | 14 +++++------ bigdata/spark/spark-rdd.md | 232 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------- languages/scala/sbt.md | 24 +++++++++++++++++- storage/databases/README.md | 3 ++- 5 files changed, 147 insertions(+), 128 deletions(-) $ git stash show 1 scala/sbt.md | 24 +++++++++++++++++++++++- spark/README.md | 5 +++++ spark/spark-rdd.md | 3 ++- 3 files changed, 30 insertions(+), 2 deletions(-) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-submodule.html":{"url":"cli/git-submodule.html","title":"git submodule","keywords":"","body":"git submodule 用法 git submodule [--quiet] [--cached] git submodule [--quiet] add [] [--] [] git submodule [--quiet] status [--cached] [--recursive] [--] [...] git submodule [--quiet] init [--] [...] git submodule [--quiet] deinit [-f|--force] (--all|[--] ...) git submodule [--quiet] update [] [--] [...] git submodule [--quiet] set-branch [] [--] git submodule [--quiet] summary [] [--] [...] git submodule [--quiet] foreach [--recursive] git submodule [--quiet] sync [--recursive] [--] [...] git submodule [--quiet] absorbgitdirs [--] [...] 文件目录 .gitmodules .git/config .git/modules/ .gitmodules 添加子模块后，会在项目目录下生成一个 .gitmodules 文件（.git/config 文件也会被修改），形如： [submodule \"themes/beautifulhugo\"] path = themes/beautifulhugo url = https://github.com/halogenica/beautifulhugo.git 示例 示例 描述 git submodule 列出所有的子模块 git submodule update 更新所有的子模块 git submodule update --init --recursive Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"cli/git-tag.html":{"url":"cli/git-tag.html","title":"git tag","keywords":"","body":"git tag 标签实质上是版本库的一个快照，也就是指向某个 commit 的指针。类似于分支，但不同的是分支可以移动，标签不能移动。 创建标签 # 默认标签是创建在最新提交的 commit 上 $ git tag [tag] # 例如 v1.0 # 在指定的 commit 上创建标签 $ git tag [tag] [commit] $ git tag -a [tag] -m [message] [commit] # 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字 $ git tag -s [tag] -m [message] [commit] # 用PGP签名创建标签（须首先安装 gpg，即GnuPG） 查看标签 # 查看所有标签 $ git tag # 等价于 git tag -l $ git tag -ln # 带提交信息 # 查看标签信息 $ git show [tag] 切换到标签 $ git checkout [tag] 推送标签 # 推送标签到远程 $ git push origin [tag] # 推送某个标签 $ git push origin --tags # 推送所有未推送的标签 删除标签 # 删除本地标签 $ git tag -d [tag] $ rm .git/refs/tags/[tag] # 删除远程标签 $ git push origin :refs/tags/[tag] $ git push origin :[tag] $ git push origin --delete tag [tag] Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"gui/git-gui.html":{"url":"gui/git-gui.html","title":"git gui","keywords":"","body":"git gui Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"gui/gitk.html":{"url":"gui/gitk.html","title":"gitk","keywords":"","body":"gitk 安装 # Ubuntu $ sudo apt-get install gitk 使用 $ cd gitproject/ && gitk Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/":{"url":"platforms/github/","title":"GitHub","keywords":"","body":"Github 搜索技巧 stars: >1000 in: readme filename: .gitlab-ci.yml 参考 Github Guides awesome-github Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/api/":{"url":"platforms/github/api/","title":"api","keywords":"","body":"GitHub APIs 目录 v3（RESTful） v4（GraphQL） 基本认证 用户名和密码 curl -u : https://api.github.com/user OAUTH Token 不同于直接使用用户名和密码来获取 Github 所有权限，使用 Token 可以根据需要仅开放部分权限。访问 https://github.com/settings/tokens/new 页面创建一个 Token 。 方式一 curl -u : https://api.github.com/user 方式二（推荐） 这种方式最简单且不需要用户名。 curl https://@api.github.com/user 方式三 # HTTP header $ curl -H \"Authorization: token \" https://api.github.com/user -I HTTP/1.1 200 OK X-OAuth-Scopes: repo, user X-Accepted-OAuth-Scopes: user 命令行为个人创建新的 Github 仓库 #!/bin/sh repo_name=\"test\" curl -u 'jinsyin' https://api.github.com/user/repos -d \"{\\\"name\\\":\\\"$repo_name\\\"}\" curl -u ${USER:-${GITHUBUSER}} https://api.github.com/user/repos -d \"{\\\"name\\\": \\\"${REPONAME:-${CURRENTDIR}}\\\", \\\"description\\\": \\\"${DESCRIPTION}\\\", \\\"private\\\": false, \\\"has_issues\\\": true, \\\"has_downloads\\\": true, \\\"has_wiki\\\": false}\" # Set the freshly created repo to the origin and push # You'll need to have added your public key to your github account git remote set-url origin git@github.com:${USER:-${GITHUBUSER}}/${REPONAME:-${CURRENTDIR}}.git git push --set-upstream origin master 命令行为组织自动创建 Github 仓库 #!/bin/sh GITHUB_USERNAME=\"jinsyin\" GITHUB_PASSWORD=\"xxxx\" GITHUB_ORG=\"k8sio\" GITHUB_REPO=\"k8stest\" curl -u 'jinsyin' -X POST https://api.github.com/orgs/${GITHUB_ORG}/repos -d \"{\\\"name\\\":\\\"$GITHUB_REPO\\\"}\" 获取所有 tag $ GITHUB_OWNER=\"kubernetes\" # user or organization $ GITHUB_REPO=\"kubernetes\" # https://developer.github.com/v3/git/refs/#get-all-references $ curl -ks \"https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/refs/tags\" | grep '\"ref\":.*' | cut -d '\"' -f4 | cut -d '/' -f3 常用 获取用户头像：github.com/.png 参考 Create a new repository for the authenticated user Create new github repo from command line Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/apps/":{"url":"platforms/github/apps/","title":"apps","keywords":"","body":"Github APPs https://github.com/probot/probot Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/badges.html":{"url":"platforms/github/badges.html","title":"GitHub badges","keywords":"","body":"GitHub badges https://naereen.github.io/badges/ https://shields.io/ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/flow/":{"url":"platforms/github/flow/","title":"flow","keywords":"","body":"Github flow GitHub 贡献代码 Fork 开源项目 访问 https://github.com/kubernetes/website 点击右上角的 Fork 按钮 Clone 到本地 $ git clone git@github.com:jinsyin/website.git # 添加上游仓库 $ git remote add upstream git@github.com:kubernetes/website.git # 设置不允许推送到 upstream （none：自命名） $ git remote set-url --push upstream none # 验证 $ git remote -v upstream git@github.com:kubernetes/website.git (fetch) upstream none (push) 分支管理 保持最新 # 拉取上游所有分支 $ git fetch upstream # 让本地 master 分支保持最新 $ git checkout master $ git rebase upstream/master 创建分支 # 功能分支 $ git checkout -b myfeature 保持分支同步 # 在 myfeature 分支 $ git fetch upstream $ git rebase upstream/master 注：请不要使用 git pull 代替上面的 fetch/rebase 。git pull 会执行 merge，并生成毫无意义的 merge commit 。 提交 # 如果是单行可以用 -m 参数 $ git commit Likely you go back and edit/build/test some more then commit --amend in a few cycles. Push $ git push -f ${your_remote_name} myfeature 创建 PR https://deploy-preview-8234--kubernetes-io-master-staging.netlify.com/ 参考 Understanding the GitHub flow Kubernetes Workflow Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/git.io/":{"url":"platforms/github/git.io/","title":"git.io","keywords":"","body":"Git.io Git.io 是 Github 提供的短地址服务，可用于缩短 Github 的网址（github.com、github.io）。 实践 # git.io/jinsyin -> github.com/jinsyin $ curl -i https://git.io -F \"url=https://github.com/jinsyin\" -F \"code=jinsyin\" # git.io/weplay.me -> github.com/jinsyin/jinsyin.github.io $ curl -i https://git.io -F \"url=https://github.com/jinsyin/jinsyin.github.io\" -F \"code=weplay.me\" # git.io/knowledge-base -> github.com/jinsyin/knowledge-base $ curl -i https://git.io -F \"url=https://github.com/jinsyin/knowledge-base\" -F \"code=knowledge-base\" # git.io/cloud-native-handbook -> github.com/jinsyin/cloud-native-handbook $ curl -i https://git.io -F \"url=https://github.com/jinsyin/cloud-native-handbook\" -F \"code=cloud-native-handbook\" # git.io/cloud-native -> jinsyin.github.io/cloud-native-handbook $ curl -i https://git.io -F \"url=https://jinsyin.github.io/cloud-native-handbook\" -F \"code=cloud-native\" $ curl -i https://git.io -F \"url=https://jinsyin.github.io/cloud-native-handbook?gitio=cloudnative\" -F \"code=cloudnative\" 注意事项： Git.io 需要 Fan 墙 谨慎实践，因为一旦设置将不能再更改 不能将多个短地址指向同一个目标 URL（不过可以通过增加 # 或 ? 来间接解决），即使请求成功最终也不会生效 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/hub/":{"url":"platforms/github/hub/","title":"hub","keywords":"","body":"Hub 安装 # macOS $ brew install hub # 验证 $ hub version 别名 # zsh $ echo 'eval \"$(hub alias -s)\"' >> ~/.zshrc 示例 $ hub clone rtomayko/tilt # git clone git://github.com/rtomayko/tilt.git 参考 hub: USE GITHUB FROM THE COMMAND-LINE github.com/github/hub Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/marketplace/":{"url":"platforms/github/marketplace/","title":"marketplace","keywords":"","body":"Github Marketplace Travis-CI - 构建工具 CodeCov - 测试覆盖率工具 JaCoCo - 生成测试覆盖率报告 Codacy - 代码质量工具 Shields - 徽标 参考 10 个实用的 GitHub 插件 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/marketplace/imgbot/":{"url":"platforms/github/marketplace/imgbot/","title":"imgbot","keywords":"","body":"ImgBot 优化流程 在 Github Marketplace 搜索并安装 imgbot，并将其应用到相应项目或所有项目 安装完成后，如果对应项目存在可优化的图片，ImgBot 会自动创建一个 imgbot 分支并完成优化提交，同时发起一个 PR 合并此 PR（“rebase and merge”） 手动删除 imgbot 分支，或者等待 ImgBot 自动删除 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/octoverse/":{"url":"platforms/github/octoverse/","title":"octoverse","keywords":"","body":"GitHub Octoverse https://octoverse.github.com/ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/":{"url":"platforms/github/pages/","title":"pages","keywords":"","body":"Github Pages Github Pages 是一个面向个人、组织或项目开放的基于 Github 仓库的静态网站托管服务。 利用 Github Pages 提供的网站功能，每个 Github 账号或组织可以创建 一个 网站，以及 无数个 项目网站。 目录 创建站点 面向个人（限一个） 面向组织（限一个） 面向项目（无数个） 设置主题 定制域名 配置文件 Jekyll 版本：https://pages.github.com/versions.json 参考 Github Pages GitHub Pages Basics Using a custom domain with GitHub Pages Adding a Jekyll theme to your GitHub Pages site with the Jekyll Theme Chooser GitHub pages cheatsheet Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/config.html":{"url":"platforms/github/pages/config.html","title":"配置文件","keywords":"","body":"配置文件 _config.yml baseurl: /demo encoding: utf-8 theme: jekyll-theme-architect _layouts/ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/domain.html":{"url":"platforms/github/pages/domain.html","title":"Github Pages 自定义域名","keywords":"","body":"Github Pages 自定义域名 目的 使用自定义域名来服务站点，而非默认的 username.github.io 无自定义域名时 假设所有项目都为 GitHub Pages 设置了 source： .github.io -> github.com//.github.io .github.io/project -> github.com//project 流程 前提是设置好了网站源，否则不能出现 Custom domain 子项 确保原站点可访问 添加自定义域名到 Github Pages 站点：「Settings」 -> 「Options」 -> 「GitHub Pages」 -> 「Custome domain」 开启 HTTPS（自 2018 年 5 月 1 日起，Github Pages 的自定义域名支持 HTTPS 请求） 在域名提供商网站设置自定义域名 子域名（如：www.example.com），必须是 CNAME 记录 域名策略 域名策略 DNS 记录 www.weplay.me -> jinsyin.github.io CNAME project.weplay.me -> jinsyin.github.io/project 不支持的自定义域名 使用多个顶级域名，如 example.com 和 weplay.me 一同使用 使用多个 www 子域名，如 www.example.com 和 www.weplay.me 一同使用 同时使用顶级域名和自定义子域名，如 weplay.me 和 blog.weplay.me 一同使用 子域名 顶级域名 设置自定义域名： 只需要对 jinsyin.github.io 项目设置自定义域名为 weplay.me 即可，其他项目无需再设置该域名，并且也不能再设置为 weplay.me（提示被占用）。 解析方式（选择 CNAME 或 A 记录）： // CNAME weplay.me -> jinsyin.github.io // A 记录（任选一个）：weplay.me -> 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 设置域名解析后： 访问 weplay.me，等同先前的 jinsyin.github.io 访问 weplay.me/project，等同先前的 jinsyin.github.io/project（假设 project 仓库为 GitHub Pages 设置了 source 但没有设置自定义域名） —— 即 project 项目使用跟 jinsyin.github.io 项目相同的域名 访问 jinsyin.github.io，将显式重定向到 weplay.me 访问 jinsyin.github.io/project，将显式重定向到 weplay.me/project 测试 CNAME 的解析结果： # Linux $ dig weplay.me +noall +answer weplay.me. 226 IN A 185.199.110.153 weplay.me. 226 IN A 185.199.111.153 weplay.me. 226 IN A 185.199.109.153 weplay.me. 226 IN A 185.199.108.153 场景 如果只有一个域名： example.com -> github.com/jinsyin/jinsyin.github.io 参考 About custom domains and GitHub Pages Managing a custom domain for your GitHub Pages site Custom domains on GitHub Pages gain support for HTTPS 我们来“劫持”个GitHub自定义域名玩吧！ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/site.html":{"url":"platforms/github/pages/site.html","title":"Github Pages 站点","keywords":"","body":"Github Pages 站点 数据源 面向 域名 数据源（Pages 分支） 个人 username.github.io * master 分支 组织 orgname.github.io * master 分支 项目 username.github.io/projectname 1. gh-pages 分支 2. master 分支 3. master 分支下的 docs/ 目录 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/theme.html":{"url":"platforms/github/pages/theme.html","title":"Theme","keywords":"","body":"Theme Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/theme/":{"url":"platforms/github/pages/theme/","title":"theme","keywords":"","body":"Github Pages 主题 内置主题 限 Jekyll 静态网站生成器。 Supported themes 配置流程 注意：由于 Github 的主题是针对 Jekyll 框架的，所以只有 index.md 和 README.md 才会自动应用主题，而 index.html 并不会（pages.github.com 的介绍有误导） 到项目页面中点击 Settings 选项并滚动到 GitHub Pages 区域，在 Theme chooser 下点击 Choose a theme 按钮 选择 Github 内置的主题后，点击 Select theme 按钮保存 设置好主题后，Github 会在项目下添加一个 _config.yml 文件用于配置 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/theme/css.html":{"url":"platforms/github/pages/theme/css.html","title":"主题的 CSS","keywords":"","body":"主题的 CSS Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/theme/layout.html":{"url":"platforms/github/pages/theme/layout.html","title":"主题的 HTML 布局","keywords":"","body":"主题的 HTML 布局 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/pages/workflow.html":{"url":"platforms/github/pages/workflow.html","title":"流程","keywords":"","body":"流程 面向个人/组织 创建代码仓库 创建一个名为 username.github.io 的代码仓库，其中 username 必须与自己的用户名或组织名保持一致。 克隆代码仓库 $ git clone https://github.com/username/username.github.io.git 新建页面 $ cd username.github.io $ echo \"Hello, world\" > index.html 推送到 Github $ git add --all $ git commit -m \"Try Github Pages\" $ git push -u origin master 浏览器访问 稍等片刻后，浏览器访问 https://username.github.io 地址即可。 面向项目 gh-pages 或 master 分支作为源： 检查 commit：https://github.com///commits/master> 在项目根目录创建 index.html 或 index.md 或 README.md 文件（优先级从左往右递减）并添加一些内容 到项目页面中点击 Settings 选项并滚动到 GitHub Pages 区域，选择 gh-pages 分支或 master 分支作为源 浏览器访问 http://username.github.io/project 如果网站不能访问说明构建出错，需要回到 Settings > GitHub Pages 查看具体的错误提示；意味着可以利用 Github Pages 功能来检查项目的某些问题 子目录作为源： 在项目子目录 /docs 下创建 index.html 或 index.md 文件并添加一些内容 到项目页面中点击 Settings 选项并滚动到 GitHub Pages 区域，选择 master branch /docs folder 作为源 浏览器访问 http://username.github.io/project 如果网站不能访问说明构建出错，需要回到 Settings > GitHub Pages 查看具体的错误提示；意味着可以利用 Github Pages 功能来检查项目的某些问题 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/":{"url":"platforms/github/repository/","title":"repository","keywords":"","body":"Github 仓库管理 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/doc/":{"url":"platforms/github/repository/doc/","title":"doc","keywords":"","body":"文档化项目 .md 文件从 repository 发布到 github pages 后，文件编码会自动由 utf-8 转为 utf-8 with BOM ，从而导致 md 文件出现中文乱码，解决办法是，直接将md文件保存为utf-8 with BOM，重新提交。 wiki Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/fork/":{"url":"platforms/github/repository/fork/","title":"fork","keywords":"","body":"fork Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/fork/contribute.html":{"url":"platforms/github/repository/fork/contribute.html","title":"Github 贡献","keywords":"","body":"Github 贡献 参考 GitHub - 对项目做出贡献 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/issue/":{"url":"platforms/github/repository/issue/","title":"issue","keywords":"","body":"Github Issue 目录 参考 Mastering Issues Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/issue/template.html":{"url":"platforms/github/repository/issue/template.html","title":"Github Issue 模板","keywords":"","body":"Github Issue 模板 在项目页面点击【Settings】选项，滚动到 Features 栏，在 issues 复选框下点击 Set up templates 按钮 Github 内置了三种 issue 模板，可以根据自己的需求添加或修改某个模板 Bug report Feature request Custom issue template 点击右上方的 【Propose changes】 按钮提交此次修改 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/pr/":{"url":"platforms/github/repository/pr/","title":"pr","keywords":"","body":"Github Pull Request（PR） 合并方式 合并方式 描述 create a merge commit 将 PR 分支（compare）和基分支（base）进行合并，并产生一个 merge 提交 —— PR 分支和基分支新的交叉 squash and merge 将 PR 分支上与基分支分叉后的所有提交（预）组合成一个提交后应用到基分支上，最终，PR 分支保持不变，主分支生成一个新的提交 rebase and merge 将 PR 分支上与基分支分叉后的所有提交重新应用到基分支上，最终 PR 分支保存不变，主分支产生新的提交（本地的 git rebase 是基分支不变，源分支更新到了基分支） 工作流程 通过 Github Web 页面且修改单个文件： 如果知识普通贡献者而且是第一次 PR，需要先 Fork 上游项目 直接在上游项目选择某个文件进行编辑，然后提交到自己的某个分支，比如 patch-1（最好不要是 master 分支） 没有直接对自己 Fork 后的项目进行编辑，是因为这样可以确保提交的内容一直新与上游分支，没有分叉 发起 PR 请求，并对比 :patch-1 和 :master 之间差别 如果发起的 PR 存在问题（无论是否经过了管理员 Review）需要修改，可以直接在 patch-1 分支上进行修改并提交，相应的 PR 页面将自动出现多个 commit，而不需要关闭再重开，最终管理员通常会选择 squash and merge 将多个 commit 合成一个 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/project/":{"url":"platforms/github/repository/project/","title":"project","keywords":"","body":"Github Project 用途 在同一处协调、跟踪和更新相关工作，使项目保持透明并按计划进行 模板 模板 描述 Basic Kanban 基础看板，附带三列：To do、In progress 和 Done Automated kanban 内置触发器，可以自动将 Issue 和 PR 移到 To do、In progress 和 Done（创建 Issue 时需要在 Issue 页面点击 “Projects” 按钮手动添加到相应看板，之后可以选择列） Automated kanban with reviews 在 Automated kanban 的基础上增加了 PR Reviews 的触发器 Bug triage 对 BUG 进行分类和优先级排序，附带四列：To do、High priority、Low priority 和 Closed Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/release/":{"url":"platforms/github/repository/release/","title":"release","keywords":"","body":"Github Release Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/repository/wiki/":{"url":"platforms/github/repository/wiki/","title":"wiki","keywords":"","body":"Github wiki Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/github/topics/":{"url":"platforms/github/topics/","title":"topics","keywords":"","body":"Github Topics 设置 搜索 github.com/topics github.com/topics/k8s Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitlab/":{"url":"platforms/gitlab/","title":"GitLab","keywords":"","body":"GitLab 参考 基于 GitLab 的团队协作模式 - 前生篇 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitlab/pages.html":{"url":"platforms/gitlab/pages.html","title":"pages","keywords":"","body":"GitLab Pages 参考 GitLab Pages Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gogs/":{"url":"platforms/gogs/","title":"gogs","keywords":"","body":"Gogs 参考 Gogs 快速入门 参考 github.com/gogs/gogs Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/":{"url":"platforms/gitbook/","title":"GitBook","keywords":"","body":"GitBook 旧版与新版 版本 官网 个人/组织主页 项目名称 项目主页 旧版 legacy.gitbook.com legacy.gitbook.com/@ Book .gitbooks.io/ 新版 gitbook.com app.gitbook.com/@（需要权限） Space .gitbook.io/ 注意事项： GitBook 旧版项目主页的顶级域名是 gitbooks.io，而新版是 gitbook.io。 GitBook 新版登录时需要 FAN 墙，浏览项目时不需要，并且 gitbook.io（新版）比 gitbooks.io（旧版） 更加流畅 对于新版，直接访问 .gitbook.io 将跳转到默认 Space，即 .gitbooks.io/ 对于旧版，直接访问 .gitbooks.io，将跳转到 legacy.gitbook.com/@，最终将进入用户或组织的主页 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/cli/":{"url":"platforms/gitbook/cli/","title":"cli","keywords":"","body":"gitbook-cli 对于没有添加到 SUMMARY.md 的文件（不论文件扩展名）或文件名比较特殊的 Markdown 文件（比如文件名包含括号），构建静态网站时不会生成 HTML 静态文件，而是原封不动的复制一份 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/cli/cli/":{"url":"platforms/gitbook/cli/cli/","title":"cmds","keywords":"","body":"cmds Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/cli/cli/gitbook-build.html":{"url":"platforms/gitbook/cli/cli/gitbook-build.html","title":"gitbook build","keywords":"","body":"gitbook build Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/cli/cli/gitbook-serve.html":{"url":"platforms/gitbook/cli/cli/gitbook-serve.html","title":"gitbook serve","keywords":"","body":"gitbook serve Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/cli/quickstart.html":{"url":"platforms/gitbook/cli/quickstart.html","title":"快速入门","keywords":"","body":"快速入门 本地安装 安装要求 Node.js 版本在 v4.0.0 及以上 Windows, Linux, Unix, or Mac OS X 安装 nodejs 和 npm # Ubuntu $ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - $ sudo apt-get install -y nodejs $ node --version v8.11.1 $ npm --version 5.6.0 安装 GitBook $ npm install gitbook-cli -g gitbook-cli 工具用于在同一系统上安装和使用多个版本的 GitBook。它会自动安装所需版本的 GitBook 来构建一本书。 创建一本书 # 在当前目录下初始化 GitBook 项目 $ gitbook init # other: gitbook init ./directory # 本地预览 $ gitbook serve # other: gitbook serve ./directory # 构建静态站点，生成的静态站点可直接托管搭载 Github Pages 服务上 $ gitbook build # other: gitbook build ./directory --output=./outputFolder 项目结构 $ gitbook init $ tree . . ├── README.md └── SUMMARY.md README.md 和 SUMMARY.md 是 GitBook 项目必须包含的两个文件。其中，README.md 相当于一本书的简介，而 SUMMAY 则用于描述书的目录结构。 参考 Setup and Installation of GitBook Installing Node.js via package manager gitbook 入门教程之使用 gitbook.com 在线开发电子书 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/domain.html":{"url":"platforms/gitbook/domain.html","title":"GitBook 自定义域名","keywords":"","body":"GitBook 自定义域名 支持域名 GitBook 并不支持所有类型的域名，其中就包括顶级域名。 类型 示例 支持？ 子域名 www.weplay.me、book.weplay.me Yes 顶级域名 weplay.me No 定制流程 旧版 在 GitBook Book 的设置页面添加自定义域名，如 k8s.weplay.me 前往 weplay.me 域名所指定的 DNS 解析商设置 CNAME 记录：k8s.weplay.me -> www.gitbooks.io GitBook 默认支持 HTTPS，稍等片刻后直接访问 https://k8s.weplay.me 自定义完成后，原先的 Book 主页 .gitbooks.io/ 依然可以访问 新版 在 GitBook Space 的设置页面添加自定义域名，如 k8s.weplay.me 前往 weplay.me 域名所指定的 DNS 解析商设置 CNAME 记录：k8s.weplay.me -> hosting.gitbook.com 过一段时间后，访问 https://k8s.weplay.me Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/domain/":{"url":"platforms/gitbook/domain/","title":"domain","keywords":"","body":"Domain Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/gitbook-summary-generator.html":{"url":"platforms/gitbook/gitbook-summary-generator.html","title":"Gitbook Summary Generator","keywords":"","body":"Gitbook Summary Generator Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/release.html":{"url":"platforms/gitbook/release.html","title":"发布","keywords":"","body":"发布 GitHub Pages 支持从三个地方读取文件 master 分支的 docs/ 目录 master 分支的根目录 gh-pages 分支的根目录 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"platforms/gitbook/summary.html":{"url":"platforms/gitbook/summary.html","title":"GitBook SUMMARY","keywords":"","body":"GitBook SUMMARY 生成器 安装 $ npm install -g gitbook-summary 使用 $ cd /path/to/mygitbook $ book sm Finished, generated 'SUMMARY.md' successfully. Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"misc/binaryfile&textfile.html":{"url":"misc/binaryfile&textfile.html","title":"二进制文件 & 文本文件","keywords":"","body":"二进制文件 & 文本文件 类型 描述 示例 文本文件 字符编码（UTF-8、ASCII、UNICODE） 源程序文件(.py、.java 等)、.md、.rst、.txt、.csv、.sh 二进制文件 自定义编码 .docx/.pptx/.xlsx/.exe Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"misc/githug/":{"url":"misc/githug/","title":"githug","keywords":"","body":"Githug 参考 Githug Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"misc/issues/git-error.html":{"url":"misc/issues/git-error.html","title":"Git 错误整理","keywords":"","body":"Git 错误整理 错误 1 push 到远程仓库是错误 $ git push origin master To git@github.com:JinsYin/learn-git.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'git@github.com:JinsYin/learn-git.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 解决办法: 方法1： 强推，即利用强覆盖方式用本地仓库的代码替代远程仓库内的内容 $ git push -f origin master 方法2：先把远程仓库的内容 fetch 到本地，然后 merge，之后再 push 到远程仓库。 # 两个命令等价于 git pull $ git fetch $ git merge git pull 之后又出错了 warning: no common commits remote: Counting objects: 21, done. remote: Compressing objects: 100% (8/8), done. Unpacking objects: 100% (21/21), done. remote: Total 21 (delta 4), reused 21 (delta 4), pack-reused 0 From github.com:JinsYin/learn-git * [new branch] master -> origin/master There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details git pull If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/ master Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "}}